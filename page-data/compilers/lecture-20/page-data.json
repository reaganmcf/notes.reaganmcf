{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-20/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 20 - Code Generation, IRs</h1>\n<p>Roadmap for the remainder of the course</p>\n<ul>\n<li>Project #2 - Due Friday April 15</li>\n<li>Homework #5 has been posted</li>\n<li>Final exam on May 10th, 1:00 pm</li>\n<li>Grading scheme\n<ul>\n<li>Exams: 2 x 30% (best 2 count)</li>\n<li>Projects: 3 x 10%</li>\n<li>Homework: 5 x 2% (best 5 count)</li>\n</ul>\n</li>\n</ul>\n<h2>Code Generation</h2>\n<p><img src=\"https://i.gyazo.com/609252d9cd20ff84abcfc02c86eab2ce.png\" alt=\"\"></p>\n<p>A compiler is a lot of fast stuff followed by some hard problems</p>\n<ul>\n<li>The hard stuff is mostly in <strong>code generation</strong> and <strong>optimization</strong></li>\n<li>For super scalars, its allocation &#x26; scheduling that is particularly important</li>\n</ul>\n<h3>Review - Generating Code</h3>\n<p>The key code quality issue is holding values in registers</p>\n<ul>\n<li>When can a value be safely allocated to a register?\n<ul>\n<li>When only 1 name can reference its value (no aliasing)</li>\n<li>Pointers, parameters, aggregates &#x26; arrays all cause trouble</li>\n</ul>\n</li>\n<li>When should a value be allocated to a register?\n<ul>\n<li>When its both <strong>safe</strong> and <strong>profitable</strong></li>\n</ul>\n</li>\n</ul>\n<p>Encoding this knowledge into the IR (register-register model)</p>\n<ul>\n<li>Use code shape to make it known to every later phase</li>\n<li>Assign a virtual register to anything that can go in one</li>\n<li>Load or store the others at each reference</li>\n</ul>\n<p>Relies on a strong register allocator</p>\n<h3>Recursive Treewalk vs. ad-hoc SDT</h3>\n<p><img src=\"https://i.gyazo.com/beff7ad239735d4011731d8a3a5a5c2c.png\" alt=\"\"></p>\n<h3>Handling Assignment</h3>\n<p><code class=\"language-text\">lhs &lt;- rhs</code></p>\n<p>Strategy</p>\n<ul>\n<li>\n<p>Evaluate <em>rhs</em> to a <strong>value</strong></p>\n</li>\n<li>\n<p>Evaluate <em>lhs</em> to a <strong>location (memory address)</strong></p>\n<ul>\n<li><em>lvalue</em> is an address => store rhs</li>\n</ul>\n</li>\n<li>\n<p>If <em>rvalue</em> &#x26; <em>lvalue</em> have different types</p>\n<ul>\n<li>Evaluate <em>rvalue</em> to its “natural” type</li>\n<li>Convert that value to the type of lhs <em>value</em>, if possible</li>\n</ul>\n</li>\n<li>\n<p>Unambiguous scalars may go into registers (no aliasing)</p>\n</li>\n<li>\n<p>Ambiguous scalars or aggregates go into memory (possible aliasing)</p>\n</li>\n</ul>\n<p>What if the compiler cannot determine the rhs’s type?</p>\n<ul>\n<li>This is a property of the language &#x26; the specific program</li>\n<li>If type safety is desired, compiler must insert a <em>run-time</em> check</li>\n<li>Add a <strong>tag field</strong> to the data items to hold type information</li>\n</ul>\n<p>Code for assignment becomes more complex</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">evaluate rhs\nif lhs.type_tag != rhs.type_tag\n  then\n    convert rhs to type(lhs) or signal a run time error\nlhs &lt;- rhs</code></pre></div>\n<h4>Compile time type checking</h4>\n<ul>\n<li>The goal is to eliminate both the runtime check &#x26; the tag</li>\n<li>Determine, at compile time, the type of each sub expression</li>\n<li>Use compile-time types to determine if a run-time check is needed</li>\n</ul>\n<h4>Optimization strategy</h4>\n<ul>\n<li>If compiler knows the type, move the check to compile time</li>\n<li>Unless tags are needed for garbage collection, eliminate them</li>\n<li>If check is needed, try to overlap it with other computation (superscalar or multi-core architectures)</li>\n</ul>\n<h4>Reference Counting</h4>\n<p>The problem with reference counting</p>\n<ul>\n<li>Must adjust the count on each <strong>pointer assignment</strong></li>\n<li>Overhead is significant, relative to assignment</li>\n</ul>\n<p>Code for assignment becomes</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">evaluate rhs\nlhs->count &lt;- lhs->count - 1\nlhs &lt;- addr(rhs)\nrhs->count &lt;- rhs->count + 1</code></pre></div>\n<p>This adds 1 <code class=\"language-text\">add</code>, 1 <code class=\"language-text\">sub</code>, 2 <code class=\"language-text\">load</code>s and 2 <code class=\"language-text\">store</code>s</p>\n<p>With extra functional units &#x26; large caches, this may become either cheap or free. <strong>What about power consumption</strong></p>\n<h3>Arrays</h3>\n<p>How does the compiler handle <code class=\"language-text\">A[i,j]</code>?</p>\n<p>First, we must agree on a storage scheme</p>\n<ul>\n<li><strong>Row-major order</strong>\n<ul>\n<li>Lay out as a sequence of consecutive rows</li>\n<li>Rightmost subscript varies fastest</li>\n<li><code class=\"language-text\">A[1,1], A[1,2], A[1,3], A[2,1], A[2,2], A[2,3]</code></li>\n<li>Most languages do this</li>\n</ul>\n</li>\n<li><strong>Column-major order</strong>\n<ul>\n<li>Lay out as a sequence of columns</li>\n<li>Leftmost subscript varies fastest</li>\n<li><code class=\"language-text\">A[1,1], A[2,1], A[1,2], A[2,2], A[1,3], A[2,3]</code></li>\n<li>Fortran does this</li>\n</ul>\n</li>\n<li><strong>Indirection vectors</strong>\n<ul>\n<li>Vector of pointers to pointers to … to values</li>\n<li>Takes much more space, takes indirection for arithmetic</li>\n<li>Not amenable to analysis</li>\n</ul>\n</li>\n</ul>\n<h4>Layout</h4>\n<p><img src=\"https://i.gyazo.com/83acb7abc98f7e083cca1b18eca6661a.png\" alt=\"\"></p>\n<h4>Computing an Array Address</h4>\n<ul>\n<li><code class=\"language-text\">A[i]</code>\n<ul>\n<li>In general, <code class=\"language-text\">base(A) + (i - low) x sizeof(A[1])</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">A[i1,i2]</code>\n<ul>\n<li>Row-major order, two dimensions:\n<ul>\n<li><code class=\"language-text\">base(a) + ((i1 - low1) x (high2 - low2 + 1) + i2 - low2) x sizeof(A[1])</code></li>\n</ul>\n</li>\n<li>Column-major order, two dimensions:\n<ul>\n<li><code class=\"language-text\">base(a) + ((i2 - low2) x (high1 - low1 + 1) + i1 - low1) x sizeof(A[1])</code></li>\n</ul>\n</li>\n<li>Indirection vectors, two dimensions\n<ul>\n<li><code class=\"language-text\">*(A[i1])[i1]</code> - where <code class=\"language-text\">A[i1]</code> is, itself, a 1d array reference</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>Optimizing 2d Array Accesses</h4>\n<p><img src=\"https://i.gyazo.com/8ac9a16060eaf511a08958c01b32fc85.png\" alt=\"\"></p>\n<h3>Control Flow</h3>\n<p>One possible approach for code generation:</p>\n<p><img src=\"https://i.gyazo.com/2f52a2e242434d35f504759d57e8aa6f.png\" alt=\"\"></p>\n<p>Loops:</p>\n<ul>\n<li>\n<p>Evaluate condition before loop (if needed)</p>\n</li>\n<li>\n<p>Evaluate condition after loop</p>\n</li>\n<li>\n<p>Branch back to the top (if needed)</p>\n</li>\n<li>\n<p>Merges test with last block of loop body</p>\n</li>\n<li>\n<p><code class=\"language-text\">while</code>, <code class=\"language-text\">for</code>, <code class=\"language-text\">do</code>, and <code class=\"language-text\">until</code> all fit this basic model</p>\n</li>\n</ul>\n<h4>Loop Implementation Code</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (i = 1; i &lt; 100; i++) { body}\n  next statement</code></pre></div>\n<p>Would get turned into</p>\n<p><img src=\"https://i.gyazo.com/c562a0dce18f9c4646685a33709febaf.png\" alt=\"\"></p>\n<h4>Break statements</h4>\n<p>Many modern programming languages include a <code class=\"language-text\">break</code></p>\n<ul>\n<li>Exits from the innermost control-flow statement\n<ul>\n<li>Out of the innermost loop</li>\n<li>Out of a case statement</li>\n</ul>\n</li>\n<li>Translates into a jump\n<ul>\n<li>Targets statement outside control-flow construct</li>\n<li>Creates multiple-exit construct</li>\n<li>Skip in loop goes to next iteration</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/83f4861d312421bf856b81dbfe465322.png\" alt=\"\"></p>","frontmatter":{"date":"April 11, 2021","slug":"/compilers/lecture-20","title":"Compilers - Lecture 20"}}},"pageContext":{"id":"4a6c85e6-0131-5cc3-b9d8-99500edf7212","frontmatter__slug":"/compilers/lecture-20","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}