{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-17/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 17 - Syntax Analysis Part 6 and Context-Sensitive Analysis</h1>\n<h2>YACC: <code class=\"language-text\">parse.y</code></h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">%{\n#include &lt;stdio.h>\n#include \"attr.h\"\nint yylex();\nvoid yyerror(char * s);\n#include \"symtab.h\"\n%}\n\n%union { tokentype token; }\n\n%token PROG PERIOD PROC VAR ARRAY RANGE OF\n%token INT REAL DOUBLE WRITELN THEN ELSE IF\n%token BEG END ASG NOT\n%token EQ NEQ LT LEQ GEQ GT OR EXOR AND DIV NOT\n%token ID CCONST ICONST RCONST\n\n%start proram\n\n%%\nprogram : PROG ID ';' block PERIOD\n  ;\nblock : BEG ID ASG ICONST END \n  ;\n%%\n\nvoid yyerror(char* s) {\n  fprintf(stderr, \"%s\\n\", s);\n}\n\nint main() {\n  printf(\"1\\t\");\n  yyparse();\n  return 1;\n}</code></pre></div>\n<h3>Error Recovery in Shift-Reduce Parsers</h3>\n<p>The problem: parser encounters an invalid token\nGoal: Want to parse the rest of the file</p>\n<p>Basic idea (panic mode):</p>\n<ul>\n<li>Assume something went wrong while trying to find handle for non terminal A</li>\n<li>Pretend handle for A has been found; pop ‚Äúhandle‚Äù, skip over input to find terminal that can follow A</li>\n</ul>\n<p>Restarting the parser (panic mode):</p>\n<ul>\n<li>Find a restartable state on the stack (has transition for nonterminal A)</li>\n<li>Move to a consistent place in the input (token that can follow A)</li>\n<li>perform (error) reduction (for nonterminal A)</li>\n<li>print an informative message</li>\n</ul>\n<h3>Error Recovery in YACC</h3>\n<p>Yacc‚Äôs error mechanism (note: version dependent!)</p>\n<ul>\n<li>Designated token <code class=\"language-text\">error</code></li>\n<li>Used in error productions of the form <code class=\"language-text\">A -> error ùõÇ</code></li>\n<li>ùõÇ specifies synchronization points</li>\n</ul>\n<p>When error is discovered</p>\n<ul>\n<li>pops stack until it finds state where it can shift the <code class=\"language-text\">error</code> token</li>\n<li>resumes parsing to match ùõÇ\n<ul>\n<li>special cases:\n<ul>\n<li>ùõÇ = w, where w is string of terminals: skip input until w has been read</li>\n<li>ùõÇ = ùõÜ : skip input until state transition on input token is defined</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Error productions can have actions</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cmpdstmt: BEG stmt_list END\nstmt_list : stmt\n          | stmt_list ';' stmt\n          | error { yyerror(\"\\n***Error: illegal statement\\n\");}</code></pre></div>\n<p>This should:</p>\n<ul>\n<li>Throw out the erroneous statement</li>\n<li>synchronize at ‚Äô;‚Äô or ‚Äòend‚Äô (implicit: ùõÇ = ùõÜ)</li>\n<li>writes message ‚Äú***Error: illegal statement‚Äù to stderror</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/8e47d182cecc2381bff67408369c9cd6.png\" alt=\"\"></p>\n<hr>\n<h2>Context Sensitive Analysis</h2>\n<p>There is a level of correctness that is deeper than grammar</p>\n<p><img src=\"https://i.gyazo.com/bdc7c2542c54d0024b1df09590044dc5.png\" alt=\"\"></p>\n<p>To generate code, we need to understand it‚Äôs meaning!</p>\n<h3>Beyond Syntax</h3>\n<p>These questions are part of context-sensitive analysis</p>\n<ul>\n<li>Answers depend on ‚Äúvalues‚Äù, i.e., something that needs computation; not parts of speech</li>\n<li>Questions &#x26; answers involve non-local information</li>\n</ul>\n<p>How can we answer these questions?</p>\n<ul>\n<li>Use formal methods\n<ul>\n<li>Context-sensitive grammars</li>\n<li>Attribute grammars</li>\n</ul>\n</li>\n<li>Use ad-hoc techniques\n<ul>\n<li>Symbol tables</li>\n<li>Ad-hoc code</li>\n</ul>\n</li>\n</ul>\n<p>In scanning &#x26; parsing, formalism won; somewhat different story here.</p>\n<p>Telling the story</p>\n<ul>\n<li>The attribute grammar formalism is important\n<ul>\n<li>Succinctly makes many points clear</li>\n<li>Sets the stage for actual, ad-hoc practice (e.g.: yacc/bison)</li>\n</ul>\n</li>\n<li>The problems with attribute grammars motivate practice\n<ul>\n<li>Non-local computation</li>\n<li>Need for centralized information</li>\n</ul>\n</li>\n</ul>\n<p>We will cover attribute grammars, then move on to ad-hoc ideas (syntax-directed translation schemes)</p>\n<h3>Attribute Grammars (AGs)</h3>\n<p>What is an attribute grammar?</p>\n<ul>\n<li>Each symbol in the derivation (instance of a token or non-terminal) may have a value, or <em>attribute</em></li>\n<li>A context-free grammar augmented with a set of rules</li>\n<li>The rules specify how to compute a value for each attribute</li>\n</ul>\n<p><em>Example grammar</em></p>\n<p><img src=\"https://i.gyazo.com/3cfa2454dafe182e49caa20ee482871b.png\" alt=\"\"></p>\n<h4>Example</h4>\n<p><img src=\"https://i.gyazo.com/1c9d1bd0d1705680865d8db5de1bde45.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/6774663637076dfcf983d6139a561a3f.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/657385f4de62b70476f6d40c5d886672.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/81939b0d04d3a52d3943074cdd25a668.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/cde1efafc9fb74830df44c2aefa6d6b6.png\" alt=\"\"></p>\n<p>We can add rules to compute the decimal value of a signed binary number</p>\n<p><img src=\"https://i.gyazo.com/8c1b68ba0919c9a4cea1c001788a8623.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/69b01cf268d944d10cc3f21b41d647a1.png\" alt=\"\"></p>\n<p>Note: semantic rules associated with production A -> ùõÇ have to specify the values for all</p>\n<ul>\n<li><strong>synthesized</strong> attributes for A (root)</li>\n<li><strong>inherited</strong> attributes for grammar symbols in ùõÇ (children)</li>\n<li>=> rules must specify <strong>local value flow!</strong></li>\n<li>Terminals can be associated with values returned by the scanner. These input values are associated with a synthesized attribute</li>\n<li>Starting symbol cannot have inherited attributes</li>\n</ul>\n<p>If we peel away the parse tree and just show the computation‚Ä¶</p>\n<p><img src=\"https://i.gyazo.com/430c6507b6ac92a9cc69ce7537a2e62d.png\" alt=\"\"></p>\n<ul>\n<li>All that is left is the attribute dependency graph!</li>\n<li>This succinctly represents the flow of values in the problem instance</li>\n<li>The <strong>dynamic methods</strong> topologically sort this graph, then evaluates edges / nodes in that order</li>\n<li>The <strong>rule-based methods</strong> try to discover ‚Äúgood‚Äù orders by analyzing rules</li>\n<li>The <strong>oblivious methods</strong> ignore the structure of this graph</li>\n</ul>\n<p>NOTE: THIS GRAPH <strong>MUST BE ACYCLIC</strong></p>\n<h4>Using AGs</h4>\n<p>Attribute grammars can specify context-sensitive actions</p>\n<ul>\n<li>\n<p>Take values from syntax</p>\n</li>\n<li>\n<p>Perform computations with values</p>\n</li>\n<li>\n<p>Insert tests, logic, ‚Ä¶</p>\n</li>\n<li>\n<p><strong>Synthesized Attributes</strong></p>\n<ul>\n<li>Use values from children &#x26; from constants</li>\n<li><strong>S-attributed</strong> grammars: synthesized attributes only</li>\n<li>Evaluate in a single bottom-up pass</li>\n<li>Good match to LR parsing</li>\n</ul>\n</li>\n<li>\n<p><strong>Inherited Attributes</strong></p>\n<ul>\n<li>Use values from parent, constants, &#x26; siblings</li>\n<li><strong>L-attributed</strong> grammars\n<ul>\n<li>A -> X1X2..Xn and each inherited attribute of Xi depends on\n<ul>\n<li>attributes of X1X2‚Ä¶Xi-1 and inherited attributes of A</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Evaluate in a single top-down pass (left to right)</li>\n<li>Good match for LL parsing</li>\n</ul>\n</li>\n<li>\n<p>Non local computation needed lots of suppporting rules</p>\n</li>\n<li>\n<p>‚ÄúComplex‚Äù local computation is relatively easy</p>\n</li>\n</ul>\n<h4>The problems with AGs</h4>\n<ul>\n<li>Copy rules increase cognitive overhead</li>\n<li>Copy rules increase space requirements\n<ul>\n<li>Need copies of attributes</li>\n</ul>\n</li>\n<li>Result is an attributed tree\n<ul>\n<li>Must build the parse tree</li>\n<li>Either search tree for answers or copy them to the root</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"March 28, 2021","slug":"/compilers/lecture-17","title":"Compilers - Lecture 17"}}},"pageContext":{"id":"26a0da47-bed9-5f0b-b0c1-66801a611096","frontmatter__slug":"/compilers/lecture-17","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}