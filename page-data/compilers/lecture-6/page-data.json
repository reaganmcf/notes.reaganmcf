{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-6/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 6</h1>\n<h2>Register Allocation Part 2</h2>\n<h3>Live Ranges (live on exit)</h3>\n<p>Assume i and j are two instructions in a basic block</p>\n<p>A value (virtual register) is <em>live</em> between its <em>definition</em> and its <em>uses</em></p>\n<ul>\n<li>Find definitions (x &#x3C;- …) and uses (y &#x3C;- … x …)</li>\n<li>From definition to <em>last</em> use its <strong>live range</strong>\n<ul>\n<li>How many (static) definitions can you have for a virtual register?</li>\n</ul>\n</li>\n<li>Can represent live range as an interval <em>[i,j]</em> (in block)\n<ul>\n<li>Live on exit</li>\n</ul>\n</li>\n</ul>\n<p>Let <em>MAXLIVE</em> be the maximum, over each instruction <em>i</em> in the block, of the number of values (virtual registers) live at <em>i</em>.</p>\n<ul>\n<li>If MAXLIVE &#x3C;= k, allocation should be easy\n<ul>\n<li>No need to reserve set of <em>F</em> registers for spilling</li>\n</ul>\n</li>\n<li>If MAXLIVE > k, some values must be spilled to memory</li>\n</ul>\n<p><strong>Finding live ranges is harder in the global case</strong></p>\n<p>Example:</p>\n<p><img src=\"https://i.gyazo.com/c3251de82c7dceb591318e55a0e03c7d.png\" alt=\"\"></p>\n<ul>\n<li>The live ranges of r1 and r3 do <strong>not</strong> overlap\n<ul>\n<li>r2, r3 are live on exit</li>\n<li>r1 is not live on exit</li>\n</ul>\n</li>\n</ul>\n<p><strong>Physical register</strong> ra assigned to r1 can also be re-assigned to r3</p>\n<p><img src=\"https://i.gyazo.com/d85f03932ab52ca35972c775ccf6d62c.png\" alt=\"\"></p>\n<h4>Register allocation as a graph coloring problem:</h4>\n<p>Interference Graph:</p>\n<ul>\n<li>Nodes: live ranges</li>\n<li>Edges: live at the same time</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/4ab88a9d53329e5dd186dcb7ab4bf9d2.png\" alt=\"\"></p>\n<p>Graph coloring problem</p>\n<ul>\n<li>Color all nodes</li>\n<li>Use minimal number of colors such that no adjacent nodes have the same color</li>\n</ul>\n<p>Answer: 2 colors</p>\n<p><img src=\"https://i.gyazo.com/71ed0946e690c74329cc417df8d6496a.png\" alt=\"\"></p>\n<h2>Top Down Allocator</h2>\n<p>The idea:</p>\n<ul>\n<li>Machine has <em>k</em> physical registers</li>\n<li>Keep the “busiest” values in an assigned register</li>\n<li>Use the feasible (reserved) set, <em>F</em>, for the rest</li>\n<li><em>F</em> is the minimal set of registers needed to execute any instruction with all operands in memory\n<ul>\n<li>Move values with no assigned register from/to memory by adding LOADs and STOREs (SPILL CODE)</li>\n</ul>\n</li>\n</ul>\n<p>Basic algorithm (not graph coloring!)</p>\n<ul>\n<li>Rank values by number of occurrences (or some other metric)</li>\n<li>Allocate first k to F values to registers</li>\n<li>Rewrite code (with spill code) to reflect these choices</li>\n</ul>\n<h3>Example</h3>\n<p>Take the following ILOC code with the live ranges (on exit) for each virtual register</p>\n<div class=\"gatsby-highlight\" data-language=\"pascal\"><pre class=\"language-pascal\"><code class=\"language-pascal\">loadI   <span class=\"token number\">1028</span>    <span class=\"token operator\">=</span><span class=\"token operator\">></span> r1 <span class=\"token comment\">// r1</span>\nload    r1      <span class=\"token operator\">=</span><span class=\"token operator\">></span> r2 <span class=\"token comment\">// r1 r2</span>\nmult    r1<span class=\"token punctuation\">,</span>r2   <span class=\"token operator\">=</span><span class=\"token operator\">></span> r3 <span class=\"token comment\">// r1 r2 r3</span>\nloadI   <span class=\"token number\">5</span>       <span class=\"token operator\">=</span><span class=\"token operator\">></span> r4 <span class=\"token comment\">// r1 r2 r3 r4</span>\nsub     r4<span class=\"token punctuation\">,</span>r2   <span class=\"token operator\">=</span><span class=\"token operator\">></span> r5 <span class=\"token comment\">// r1    r3    r5</span>\nloadI   <span class=\"token number\">8</span>       <span class=\"token operator\">=</span><span class=\"token operator\">></span> r6 <span class=\"token comment\">// r1    r3    r5 r6</span>\nmult    r5<span class=\"token punctuation\">,</span>r6   <span class=\"token operator\">=</span><span class=\"token operator\">></span> r7 <span class=\"token comment\">// r1    r3          r7</span>\nsub     r7<span class=\"token punctuation\">,</span>r3   <span class=\"token operator\">=</span><span class=\"token operator\">></span> r8 <span class=\"token comment\">// r1                   r8</span>\nstore   r8      <span class=\"token operator\">=</span><span class=\"token operator\">></span> r1 <span class=\"token comment\">//</span></code></pre></div>","frontmatter":{"date":"February 07, 2021","slug":"/compilers/lecture-6","title":"Compilers - Lecture 6"}}},"pageContext":{"id":"660be430-4654-5fce-b162-acf9c2e15960","frontmatter__slug":"/compilers/lecture-6","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}