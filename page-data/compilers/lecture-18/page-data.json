{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-18/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 18 - Context-Sensitive Analysis Part 2</h1>\n<h2>Midterm #2</h2>\n<ul>\n<li>Regular Expressions</li>\n<li>NFA and DFA</li>\n<li>Regular Expressions to minimal DFA construction</li>\n<li>CFG\n<ul>\n<li>Derivations</li>\n<li>Parse Trees</li>\n<li>ambiguity</li>\n</ul>\n</li>\n<li>LL(1) parsing\n<ul>\n<li>FIRST and FOLLOW sets</li>\n<li>Parse tables</li>\n<li>Recursive descent parsers</li>\n</ul>\n</li>\n<li>LR(0) parsing\n<ul>\n<li>LR(0) items</li>\n<li>LR(0) canonical collection and its construction</li>\n<li>ACTION and GOTO tables</li>\n<li>Shift/reduce and reduce/reduce conflicts</li>\n</ul>\n</li>\n</ul>\n<h2>Attribute Grammars, cont.</h2>\n<p>The Problems:</p>\n<ul>\n<li>Copy rules increase cognitive overhead</li>\n<li>Copy rules increase space requirements\n<ul>\n<li>Need copies of attributes</li>\n</ul>\n</li>\n<li>Result is an attributed tree\n<ul>\n<li>Must build the parse tree</li>\n<li>Either search tree for answers or copy them to the root</li>\n</ul>\n</li>\n</ul>\n<h3>Addressing the Problem</h3>\n<p>What would a good programmer do?</p>\n<ul>\n<li>Introduce a central repository for facts</li>\n<li>Table names\n<ul>\n<li>Field in table for loaded/not loaded state</li>\n</ul>\n</li>\n<li>Avoid all the copy rules, allocation &#x26; storage headaches</li>\n<li>All inter-assignment attribute flow is through table\n<ul>\n<li>Clean, efficient implementation</li>\n<li>Good techniques for implementing the table</li>\n<li>When it’s done, information is in the table</li>\n<li>Cures most of the problems</li>\n</ul>\n</li>\n<li>Unfortunately, this design violates the functional, AG paradigm\n<ul>\n<li>Do we care?</li>\n</ul>\n</li>\n</ul>\n<h3>The Realist’s Alternative</h3>\n<p><strong>Ad-hoc syntax-directed translation</strong></p>\n<ul>\n<li>Associate pieces of code with each production</li>\n<li>At each reduction, the corresponding code is executed</li>\n<li>Allowing arbitrary code provides complete flexibility\n<ul>\n<li>Includes ability to do tasteless and bad things</li>\n</ul>\n</li>\n</ul>\n<p>To make this work:</p>\n<ul>\n<li>Need names for attributes of each symbol on <em>lhs</em> and <em>rhs</em>\n<ul>\n<li>Typically, one attribute passed through parser + arbitrary code (structures, globals, …)</li>\n<li>Yacc introduced $$, $1, $2, …, $n, left to right</li>\n</ul>\n</li>\n<li>Need an evaluation scheme\n<ul>\n<li>Fits nicely into LR(1) parsing algorithm</li>\n</ul>\n</li>\n</ul>\n<h2>Project 2</h2>\n<ul>\n<li>You do not have to change the scanner (scan.l)</li>\n<li>How to specify and use attributes in YACC?\n<ul>\n<li>Define attributes as types in <code class=\"language-text\">attr.h</code></li>\n<li><code class=\"language-text\">typedef struct info_node { int a; int b } infonode;</code></li>\n</ul>\n</li>\n<li>Include type attribute name in <code class=\"language-text\">%union</code> in parse.y\n<ul>\n<li><code class=\"language-text\">%union {tokentype token; infonode myinfo; ... }</code></li>\n</ul>\n</li>\n<li>Assign attributes in <code class=\"language-text\">parse.y</code> to\n<ul>\n<li>Terminals: <code class=\"language-text\">%token &lt;token> ID ICONST</code></li>\n<li>Non-terminals: <code class=\"language-text\">%type &lt;myinfo> block variables procdecls cmpdstmt</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/52e3b37628c8e43688c4cefd17fb78dc.png\" alt=\"\"></p>\n<ul>\n<li>At each reduction, the corresponding code is executed.\n<ul>\n<li>Accessing attribute values in parse.y:</li>\n<li>use $$, $1, $2, …, etc. notation:</li>\n<li>\\s\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">block : variables procdecls {$2.b = $1.b + 1;} cmpdstmt\n        { $$.a = $1.a + $2.a + $4.b; }</code></pre></div>\n</li>\n<li>Implemented as\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">block : variables procdecls newsymbol cmpdstmt\n        { $$.a = $1.a + $2.a + $4.b; }\nnewsymbol: ∈ {$2.b = $1.b + 1;}</code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/7c8f68a6d67fd46e927a796bc460d1d4.png\" alt=\"\"></p>\n<h3>Summary - is this really ad-hoc?</h3>\n<p>Relationship between practice and attribute grammars</p>\n<p>Similarities</p>\n<ul>\n<li>Both rules &#x26; actions associated with productions</li>\n<li>Application order determined by tools</li>\n<li>(Somewhat) abstract names for symbols</li>\n</ul>\n<p>Differences:</p>\n<ul>\n<li>Actions applied as a unit; not true for AG rules</li>\n<li>Anything goes in ad-hoc actions; AG rules are (purely) functional</li>\n<li>AG rules are higher level than ad-hoc actions</li>\n</ul>\n<h2>Types and Type Systems</h2>\n<p>Type: A set of values and meaningful operations on them</p>\n<p>Types provide semantic “sanity checks” (consistency checks) and determine efficient implementations for data objects</p>\n<p>Types help identify</p>\n<ul>\n<li>errors</li>\n<li>which operation to use for overloaded names and operators, or what type coercion to use (e.g.: 3.0 + 1)</li>\n<li>identification of polymorphic functions</li>\n</ul>\n<h3>Type System</h3>\n<p><strong>Type System</strong>: each language construct (operator, expression, statement, etc.) is associated with a <em>type expression</em>. The type system is a collection of rules for assigning <em>type expressions</em> to these constructs.</p>\n<p><strong>Type expressions</strong> for</p>\n<ul>\n<li>basic types: <code class=\"language-text\">integer</code>, <code class=\"language-text\">char</code>, <code class=\"language-text\">real</code>, <code class=\"language-text\">boolean</code>, <code class=\"language-text\">typeError</code></li>\n<li>constructed types, e.g., one-dimensional arrays:\n<ul>\n<li><code class=\"language-text\">array(lb, ub, elem_type)</code>, where <code class=\"language-text\">elem_type</code> is a <em>type expression</em></li>\n</ul>\n</li>\n</ul>\n<p>A <strong>Type Checker</strong> implements a type system. It computes or “constructs” type expressions for each language construct</p>","frontmatter":{"date":"March 30, 2021","slug":"/compilers/lecture-18","title":"Compilers - Lecture 18"}}},"pageContext":{"id":"3f5bb91c-eda8-531c-a3c3-3c6a082b9e3b","frontmatter__slug":"/compilers/lecture-18","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}