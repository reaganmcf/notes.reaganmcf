{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-11/",
    "result": {"data":{"markdownRemark":{"html":"<h2>NFA -> DFA with Subset Construction</h2>\n<p>Need to build a simulation of the NFA</p>\n<p>Two key functions</p>\n<ul>\n<li><code class=\"language-text\">move(si, a)</code> is a set of states reachable from si by a</li>\n<li><code class=\"language-text\">ε-closure(si)</code> is the set of states reachable from si by ε</li>\n</ul>\n<p>The algorithm (sketch):</p>\n<ul>\n<li>Start state derived from s0 of the NFA</li>\n<li>Take its <code class=\"language-text\">ε-closure</code> S0 = <code class=\"language-text\">ε-closure(s0)</code></li>\n<li>For each state S, compute <code class=\"language-text\">move(S, a)</code> for each a ∈ Σ, and take it’s ε-closure</li>\n<li>Iterate until no more states are added</li>\n</ul>\n<p>Sounds more complex that it is…</p>\n<h4>Example</h4>\n<p><img src=\"https://i.gyazo.com/7732511a30a8b3a177675f5fcd986da1.png\" alt=\"\"></p>\n<p>Applying the subset construction:</p>\n<table>\n<thead>\n<tr>\n<th>DFA States</th>\n<th>NFA States</th>\n<th>a</th>\n<th>b</th>\n<th>c</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>s0</td>\n<td>{q0}</td>\n<td>{q1, q2 q3, q9, q4, q6 }</td>\n<td>none</td>\n<td>none</td>\n</tr>\n<tr>\n<td>s1</td>\n<td>{q1,q2,q3,q9,q4,q6}</td>\n<td>none</td>\n<td>{q5, q8, q3, q6, q4, q9}</td>\n<td>{q7, q8, q9, q3, q4, q6}</td>\n</tr>\n<tr>\n<td>s2</td>\n<td>{q5, q8, q9, q3, q4, q6 }</td>\n<td>none</td>\n<td>s2</td>\n<td>s3</td>\n</tr>\n<tr>\n<td>s3</td>\n<td>{q7, q8, q9, q3, q4, q6 }</td>\n<td>none</td>\n<td>s2</td>\n<td>s3</td>\n</tr>\n</tbody>\n</table>\n<p>Note that any NFA state that contains q9 is an accepting state, since that is the final state in the NFA</p>\n<p>The result of subset construction is the following DFA</p>\n<p><img src=\"https://i.gyazo.com/e4407a08835851e36aac2b57a320ca4c.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>δ</th>\n<th>a</th>\n<th>b</th>\n<th>c</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>s0</td>\n<td>s1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>s1</td>\n<td>-</td>\n<td>s2</td>\n<td>s3</td>\n</tr>\n<tr>\n<td>s2</td>\n<td>-</td>\n<td>s2</td>\n<td>s3</td>\n</tr>\n<tr>\n<td>s3</td>\n<td>-</td>\n<td>s2</td>\n<td>s3</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Ends up smaller than the NFA</li>\n<li>All transitions are deterministic</li>\n</ul>\n<h2>Automatic Scanner Construction</h2>\n<ul>\n<li>\n<p>RE -> NFA (Thompson’s construction)</p>\n<ul>\n<li>Build an NFA for each term</li>\n<li>Combine them with ε moves</li>\n</ul>\n</li>\n<li>\n<p>NFA -> DFA (subset construction)</p>\n<ul>\n<li>Build the simulation</li>\n</ul>\n</li>\n<li>\n<p>DFA -> Minimal DFA</p>\n<ul>\n<li>Hopcroft’s Algorithm</li>\n</ul>\n</li>\n<li>\n<p>DFA -> RE (<em>not really part of scanner construction</em>)</p>\n<ul>\n<li>All pairs, all paths problem</li>\n<li>Union together paths from s0 to a final state</li>\n</ul>\n</li>\n</ul>\n<h2>DFA Minimization</h2>\n<ul>\n<li>How do we know whether two states encode the same information?</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/6a145e1e8cbd916434a6bf9b76d2ceda.png\" alt=\"\"></p>\n<ul>\n<li>Here, q1 and q2 are not equivalent. “w” is a witness that they are not equivalent</li>\n</ul>\n<p>Intuition: Two states are equivalent if for all sequences of input symbols “w” they both lead to an accepting state, or both end up in a non-accepting state.</p>\n<h3>Big Picture</h3>\n<ul>\n<li>Discover sets of equivalent states</li>\n<li>Represent each such set with just one state</li>\n</ul>\n<p>Two states are equivalent if and only if:</p>\n<ul>\n<li>∀ a ∈ Σ, transitions on a lead to equivalent states (DFA)</li>\n<li>if a-transitions to different sets => two states must be in different sets, i.e., cannot be equivalent</li>\n</ul>\n<p>A partition <em>P</em> of <em>S</em></p>\n<ul>\n<li>Each state <strong>s</strong> ∈ <em>S</em> is in exactly one set <em>pi</em> ∈ <em>P</em></li>\n<li>The algorithm iteratively partitions the DFA’s states</li>\n</ul>\n<h3>Details of the algorithm</h3>\n<ul>\n<li>Group states into maximal size sets, <em>optimistically</em></li>\n<li>Iteratively subdivide those sets, as needed</li>\n<li>States that remain grouped together are equivalent</li>\n</ul>\n<p>Initial partition, P0, has two sets: <strong>{F}</strong> &#x26; <strong>{Q-F}</strong></p>\n<p>Splitting a set (“partitioning a set s by a”)</p>\n<ul>\n<li>Assume qa &#x26; qb ∈ s, and δ(qa, a) = qx &#x26; δ(qb, a) = qy</li>\n<li>If qx &#x26; qy are not in the same set, i.e., are considered equivalent, then <em>s</em> must be split\n<ul>\n<li>qa has transition on a, qb does not => a splits s</li>\n</ul>\n</li>\n</ul>\n<h3>Back to our DFA Minimization example</h3>\n<p><img src=\"https://i.gyazo.com/c7acdb5dc9b06637dae8e0506a4b19c1.png\" alt=\"\"></p>\n<h2>Limits of Regular Languages</h2>\n<p>Advantages of Regular Expressions</p>\n<ul>\n<li>Simple &#x26; powerful notation for specifying patterns</li>\n<li>Automatic construction of fast recognizers</li>\n<li>Many kinds of syntax can be specified with REs</li>\n</ul>\n<p>Example - an expression grammar</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Term -> [a-zA-Z]([a-zA-Z] | [0-9])*\nOp   -> + | - | * | /\nExpr -> ( Term Op )* Term</code></pre></div>\n<p>Of course, this would generate a DFA</p>\n<p>If REs are so useful…\nWhy not use them for everything?</p>\n<h3>Not all languages are regular</h3>\n<p>RL’s ⊂ CFL’s ⊂ CSL’s</p>\n<p>You cannot construct DFAs to recognize these languages</p>\n<ul>\n<li><em>L = {p^k q^k}</em></li>\n<li><em>L = {wcw^r | w ∈ Σ*}</em></li>\n</ul>\n<p>Neither of these is a regular language\nBut, this is a little subtle. You <em>can</em> construct DFA’s for</p>\n<ul>\n<li>Strings with alternating 0’s and 1’s</li>\n<li>Strings with an even number of 0’s and 1’s</li>\n<li>Strings of bit patterns that represent binary numbers which are divisible by 5 (homework)</li>\n</ul>\n<h3>What can be so hard?</h3>\n<p>Poor language design can complicate scanning</p>\n<ul>\n<li>Reserved words are important\n<ul>\n<li><code class=\"language-text\">if then then then - else; else else = then</code> (PL/I)</li>\n</ul>\n</li>\n<li>Insignificant blanks (Fortran &#x26; Algol68)\n<ul>\n<li><code class=\"language-text\">do 10 i = 1,25</code></li>\n<li><code class=\"language-text\">do 10 i = 1.25</code></li>\n</ul>\n</li>\n<li>String constants with special characters (C, C++, Java)\n<ul>\n<li>newline, tab, quote, comment delimiters</li>\n</ul>\n</li>\n<li>Limited identifier “length” (Fortran 66 &#x26; PL/I)</li>\n</ul>","frontmatter":{"date":"February 28, 2021","slug":"/compilers/lecture-11","title":"Compilers - Lecture 11"}}},"pageContext":{"id":"5bd07551-eb31-5111-b3bc-6ae5561e4363","frontmatter__slug":"/compilers/lecture-11","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}