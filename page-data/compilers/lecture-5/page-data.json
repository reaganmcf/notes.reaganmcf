{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-5/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 5</h1>\n<h2>Register Allocation</h2>\n<ul>\n<li><strong>Local</strong>: within single basic block</li>\n<li><strong>Global</strong>: across procedure / function</li>\n</ul>\n<p>Register -> Register model means you use a fresh register for each value</p>\n<p><img src=\"https://i.gyazo.com/751cf661c564da3af0493bc82eccc0f3.png\" alt=\"\"></p>\n<p>Critical properties</p>\n<ul>\n<li>Produce <strong>correct</strong> code that uses <em>k</em> (or fewer) registers</li>\n<li>Minimize added loads and stores</li>\n<li>Minimize space used to hold <em>spilled values</em></li>\n<li>Operate efficiently\n<ul>\n<li>O(n), O(n log2n), maybe O(n^2), but not O(2^n)</li>\n</ul>\n</li>\n</ul>\n<h2>Memory Model / Code Shape</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a := 1\nb := 2\nc := a + b + 3</code></pre></div>\n<p>Assumption: no aliasing</p>\n<h3>Register-Register Model</h3>\n<ul>\n<li>Values that <strong>may safely reside</strong> in registers are assigned to a unique virtual register (<strong>alias analysis; unambiguous values</strong>); there are different “flavors”</li>\n</ul>\n<p>All in registers</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loadI 1 => r1\nloadI 2 => r2\nadd r1,r2 => r3\nloadI 3 => r4\nadd r3,r4 => r5</code></pre></div>\n<p>Preserve memory view (memory consistency)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loadI 1 => r1\nstoreAI r1 => r0,@a\nloadI 2 => r2\nstoreAI r2 => r0,@b\nadd r1,r2 => r3\nloadI 3 => r4\nadd r3,r4 => r5\nstoreAI r5 => r0,@c</code></pre></div>\n<h3>Memory-Memory Model</h3>\n<ul>\n<li>All program-named values <strong>reside in memory</strong>, and are only kept in registers as briefly as possible (load operand from memory, perform computation, store result back into memory)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loadI 1 => r1\nstoreAI r1 => r0,@a\nloadI 2 => r2\nstoreAI r2 => r0,@b\nloadAI r0,@a => r3\nloadAI r0,@b => r4\nadd r3,r4 => r5\nloadI 3 => r7\nadd r5,r7 => r8\nstoreAI r8 => r0,@c</code></pre></div>\n<hr>\n<p>Consider the following fragment of assembly code (or ILOC)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loadI   2     => r1 // r1 &lt;- 2\nloadAI  r0,8  => r2 // r2 &lt;- y\nmult    r1,r2 => r3 // r3 &lt;- 2 * y\nloadAI  r0,4  => r4 // r4 &lt;- x\nsub     r4,r3 => r5 // r5 &lt;- x - (2 * y)</code></pre></div>\n<p>The problem</p>\n<ul>\n<li>At each instruction, decide which <strong>values</strong> to keep in registers\n<ul>\n<li>Note: a value is a <em>pseudo-register (virtual register)</em></li>\n<li>Simple if |values| &#x3C;= |registers|</li>\n</ul>\n</li>\n<li>Harder if |values| > |registers|</li>\n<li>The compiler must automate this process</li>\n</ul>\n<h3>The Task</h3>\n<ul>\n<li>At each point in the code, pick the values to keep in registerse</li>\n<li>Insert code to move values between registers &#x26; memory\n<ul>\n<li>No reordering transformations (leave that to scheduling)</li>\n</ul>\n</li>\n<li>Minimize inserted code - both dynamic &#x26; static measures</li>\n<li>Make good use of any <em>extra</em> registers</li>\n</ul>\n<p>Allocation versus Assignment</p>\n<ul>\n<li><strong>Allocation</strong> is deciding which values to keep in registers</li>\n<li><strong>Assignment</strong> is choosing specific registers for values</li>\n<li>This distinction is often lost in the literature\n<ul>\n<li>The compiler must perform <strong>both</strong></li>\n</ul>\n</li>\n</ul>\n<h3>Local Register Allocation</h3>\n<ul>\n<li>What’s “local”?\n<ul>\n<li>A local transformation operates on basic blocks</li>\n<li>Many optimizations are done locally</li>\n</ul>\n</li>\n<li>Does local allocation solve the problem?\n<ul>\n<li>It produces decent register use inside a block</li>\n<li>Inefficiencies can arise at boundaries between blocks</li>\n</ul>\n</li>\n<li>How many passes can the allocator make?\n<ul>\n<li>This is a compile-time (“off-line”) problem (not during program execution); typically, as many passes as it takes</li>\n</ul>\n</li>\n<li>Memory-to-Memory vs. Register-to-Register model\n<ul>\n<li>Code shape and safety issues</li>\n</ul>\n</li>\n</ul>\n<h2>Basic Approach of Allocators</h2>\n<p>Allocator may need to reserve physical registers to ensure feasibility</p>\n<p>Notation: <em>k</em> is the number of registers on the target machine</p>\n<ul>\n<li>Must be able to compute memory addresses</li>\n<li>Requires some minimal set of registers, <em>F</em>\n<ul>\n<li><em>F</em> depends on target architecture</li>\n</ul>\n</li>\n<li>F contains registers to make spilling work\n<ul>\n<li>set F registers “aside” for address computation &#x26; instruction execution, i.e., these are no available for register assignment</li>\n</ul>\n</li>\n<li>Note: F physical registers need to be able to support the pathological case where all virtual registers are spilled</li>\n</ul>\n<p>What if <em>k - |F| &#x3C; |values| &#x3C; k</em>?</p>\n<ul>\n<li>The allocator can either\n<ul>\n<li>Check for this situation</li>\n<li>Accept the fact that the technique is an approximation</li>\n</ul>\n</li>\n</ul>\n<h3>Top-down allocator</h3>\n<ul>\n<li>May use notation of <strong>live ranges</strong> of virtual registers</li>\n<li>Work from “external” notion of what is important</li>\n<li>Assign registers in priority order</li>\n<li>Register assignment <strong>remains fixed for entire basic block</strong></li>\n<li>Save some registers for the values relegated to memory (feasible set F)</li>\n</ul>\n<h3>Bottom-up allocator</h3>\n<ul>\n<li>Work from detailed knowledge about problem instance</li>\n<li>Incorporate knowledge of partial solution at each step</li>\n<li>Register assignment <strong>may change across basic block</strong></li>\n<li>Save some registers for the values relegated to memory (feasible set F)</li>\n</ul>\n<h2>Live Ranges</h2>\n<p>Assume i and j are two instructions in a basic block</p>\n<p>A value (virtual register) is <em>live</em> between its <em>definition</em> and its <em>uses</em></p>\n<ul>\n<li>Find definitions (x &#x3C;- …) and uses (y &#x3C;- … x …)</li>\n<li>From definition to <strong>last</strong> use is its <strong>live range</strong>\n<ul>\n<li>How many static definitions can you have for a virtual register</li>\n</ul>\n</li>\n<li>Can represent live range as an interval <em>[i,j]</em> (in block)\n<ul>\n<li>Live on exit</li>\n</ul>\n</li>\n</ul>\n<p>Let <em>MAXLIVE</em> be the maximum, over each instruction <em>i</em> in the block, of the number of values (virtual registers) live at <em>i</em>.</p>\n<ul>\n<li>If <em>MAXLIVE &#x3C;= k</em>, allocation should be easy\n<ul>\n<li>No need to reserve set of <em>F</em> registers for spilling</li>\n</ul>\n</li>\n<li>If <em>MAXLIVE > k</em>, some values must be spilled to memory</li>\n</ul>\n<p>Finding live ranges is harder in the global case</p>","frontmatter":{"date":"February 02, 2021","slug":"/compilers/lecture-5","title":"Compilers - Lecture 5"}}},"pageContext":{"id":"fd928c1c-0eba-5de4-948a-a5c688c40842","frontmatter__slug":"/compilers/lecture-5","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}