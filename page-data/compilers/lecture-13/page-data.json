{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-13/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 13 - More Parsing</h1>\n<h2>Top-down parsers</h2>\n<h4>LL(1), recursive descent</h4>\n<ul>\n<li>Input: read left to right</li>\n<li>Construct leftmost derivation</li>\n<li>1 input symbol look ahead</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/b308810ac88c6522d477b7272095ac4f.png\" alt=\"\"></p>\n<h4>Example</h4>\n<p>Grammar <code class=\"language-text\">S -> % S % | &amp; S &amp; | $</code></p>\n<p>Our language can be described mathematically as: <em>{w $ w^R | w ∈ (%, &#x26;)^*}</em></p>\n<p>Is this LL(1)?</p>\n<p>Yes! Because as you push the left most derivation through, <strong>you only need to look ahead one token at a time</strong>, and you end up with a deterministic parse tree.</p>\n<p>The grammar <code class=\"language-text\">S -> % S % | % &amp; S % | $</code> is NOT LL(1), but rather LL(2).</p>\n<h3>Formally defining LL(1)</h3>\n<p><em>A -> 𝝰 | 𝛃 s.t. First(𝝰) ∩ First(𝛃) = ∅</em></p>\n<p>But, how do we compute the <em>First</em> sets?</p>\n<h3>Left Recursion</h3>\n<p>Remember the expression grammar?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Goal    -> Expr\nExpr    -> Expr + Term\n        |  Expr - Term\n        |  Term\nTerm    -> Term * Factor\n        | Term / Factor\n        | Factor\nFactor  -> number\n        | id</code></pre></div>\n<p><strong>Top-down parsers cannot handle left-recursive grammars</strong></p>\n<p>Formally, A grammar is <em>left recursive</em> if ∃ A ∈ NT such that ∃ a derivation A =>^+ A𝝰, for some string 𝝰 ∈ (NT ∪ T)^+</p>\n<p>Our expression grammar is left recursive</p>\n<ul>\n<li>This can lead to non-termination in a top-down parser</li>\n<li>For a top-down parser, any recursion must be right recursion</li>\n<li>We would like to convert the left recursion to right recursion</li>\n</ul>\n<p><strong>Non-termination is a bad property in any part of a compiler</strong></p>\n<h4>Eliminating Left Recursion</h4>\n<p>To remove left recursion, we can transform the grammar</p>\n<p>Consider a grammar fragment of the form</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Fee -> Fee 𝝰\n     | 𝝱</code></pre></div>\n<p>where neither 𝝰 nor 𝝱 start with <em>Fee</em></p>\n<p>We can rewrite this as</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Fee -> 𝝱 Fie\nFie -> 𝝰 Fie\n     | 𝝴</code></pre></div>\n<p>where <em>Fie</em> is a new non-terminal</p>\n<p><strong>This accepts the same language, but uses only right recursion</strong></p>\n<h2>Roadmap (Where are we?)</h2>\n<p>We set out to study parsing</p>\n<ul>\n<li>Specifying syntax\n<ul>\n<li>Context free grammars</li>\n<li>Ambiguity</li>\n</ul>\n</li>\n<li>Top-down parsers\n<ul>\n<li>Algorithm &#x26; its problem with left recursion</li>\n<li>Left-recursion removal</li>\n<li>Left factoring (will discuss later)</li>\n</ul>\n</li>\n<li>Predictive top-down parsing\n<ul>\n<li>The LL(1) condition</li>\n<li>Table-driven LL(1) parsers</li>\n<li>Recursive descent parsers\n<ul>\n<li>Syntax directed translation (example)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Picking the “Right” production</h3>\n<p><strong>If it picks the wrong production, a top-down parser may backtrack. Alternative is to look ahead in input &#x26; use context to pick correctly</strong></p>\n<p>How much look ahead is needed?</p>\n<ul>\n<li>In general, an arbitrarily large amount</li>\n<li>Use the Cocke-Younger, Kasami algorithm or Earley’s algorithm</li>\n</ul>\n<p>Fortunately</p>\n<ul>\n<li>Large subclasses of CFGs can be parsed with limited look ahead</li>\n<li>Most programming language constructs fall in those subclasses</li>\n</ul>\n<p>Among the interesting subclasses are <em>LL(1)</em> and <em>LR(1)</em> grammars</p>\n<h2>Predictive Parsing</h2>\n<p>Basic idea\nGiven A -> 𝝰 | 𝝱, the parser should be able to choose between 𝝰 and 𝝱</p>\n<p>FIRST Sets</p>\n<ul>\n<li>For some rhs 𝝰 ∈ G, define <strong>FIRST(𝝰)</strong> as the set of tokens that appear as the first symbol in some string that derives from 𝝰</li>\n<li>That is, a ∈ FIRST(𝝰) iff a =>^* a𝝲, for some 𝝲</li>\n</ul>\n<p>The LL(1) property\nIf A -> 𝝰 and A -> 𝝱 both appear in the grammar, we would like <em>FIRST(𝝰) ∩ FIRST(𝝱) = ∅</em></p>\n<ul>\n<li>Note: This is <em>almost</em> correct, but not quite!</li>\n</ul>\n<p>This would allow the parser to make a correct choice with a look ahead of exactly one symbol!</p>\n<h3>The FIRST Set - 1 Symbol Look ahead</h3>\n<p><img src=\"https://i.gyazo.com/fc09b7d26c594a3c2d60bc1d31165440.png\" alt=\"\"></p>\n<h3>The FOLLOW Set - 1 Symbol</h3>\n<p>For a non-terminal A, define FOLLOW(A) as</p>\n<p><em>FOLLOW(A) := the set of terminals that can appear immediately to the right of A in some sentential form</em></p>\n<p>Thus, a non-terminal’s FOLLOW set specifies the tokens that can legally appear after it; a terminal has no FOLLOW set</p>\n<p><em>FOLLOW(A) = { a ∈ (T ∪ {eof}) | S eof =>^* 𝝰 A a 𝝲 }</em></p>\n<p>To build FOLLOW(X) for all non-terminal X</p>\n<ol>\n<li>Place eof in FOLLOW(&#x3C;goal>)</li>\n</ol>\n<ul>\n<li>Iterate until no more terminals or eof can be added to any FOLLOW(X)</li>\n</ul>\n<ol start=\"2\">\n<li>If A -> 𝝰B𝝱 then put {FIRST(𝝱) - 𝝴} in FOLLOW(B)</li>\n<li>If A -> 𝝰B then put FOLLOW(A) in FOLLOW(B)</li>\n<li>If A -> 𝝰B𝝱 and 𝝴 ∈ FIRST(𝝱) then put FOLLOW(A) in FOLLOW(B)</li>\n</ol>\n<p>If A -> 𝝰 and A -> 𝝱 and 𝝴 ∈ FIRST(𝝰), then we need to ensure that FIRST(𝝱) is disjoint from FOLLOW(A), too</p>\n<p><img src=\"https://i.gyazo.com/ab0480e11752f40f10fed1f3983f3c9e.png\" alt=\"\"></p>","frontmatter":{"date":"March 07, 2021","slug":"/compilers/lecture-13","title":"Compilers - Lecture 13"}}},"pageContext":{"id":"6b28c711-609b-5410-a8ac-65535bce0f52","frontmatter__slug":"/compilers/lecture-13","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}