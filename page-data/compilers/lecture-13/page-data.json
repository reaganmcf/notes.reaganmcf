{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-13/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 13 - More Parsing</h1>\n<h2>Top-down parsers</h2>\n<h4>LL(1), recursive descent</h4>\n<ul>\n<li>Input: read left to right</li>\n<li>Construct leftmost derivation</li>\n<li>1 input symbol look ahead</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/b308810ac88c6522d477b7272095ac4f.png\" alt=\"\"></p>\n<h4>Example</h4>\n<p>Grammar <code class=\"language-text\">S -> % S % | &amp; S &amp; | $</code></p>\n<p>Our language can be described mathematically as: <em>{w $ w^R | w âˆˆ (%, &#x26;)^*}</em></p>\n<p>Is this LL(1)?</p>\n<p>Yes! Because as you push the left most derivation through, <strong>you only need to look ahead one token at a time</strong>, and you end up with a deterministic parse tree.</p>\n<p>The grammar <code class=\"language-text\">S -> % S % | % &amp; S % | $</code> is NOT LL(1), but rather LL(2).</p>\n<h3>Formally defining LL(1)</h3>\n<p><em>A -> ğ° | ğ›ƒ s.t. First(ğ°) âˆ© First(ğ›ƒ) = âˆ…</em></p>\n<p>But, how do we compute the <em>First</em> sets?</p>\n<h3>Left Recursion</h3>\n<p>Remember the expression grammar?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Goal    -> Expr\nExpr    -> Expr + Term\n        |  Expr - Term\n        |  Term\nTerm    -> Term * Factor\n        | Term / Factor\n        | Factor\nFactor  -> number\n        | id</code></pre></div>\n<p><strong>Top-down parsers cannot handle left-recursive grammars</strong></p>\n<p>Formally, A grammar is <em>left recursive</em> if âˆƒ A âˆˆ NT such that âˆƒ a derivation A =>^+ Ağ°, for some string ğ° âˆˆ (NT âˆª T)^+</p>\n<p>Our expression grammar is left recursive</p>\n<ul>\n<li>This can lead to non-termination in a top-down parser</li>\n<li>For a top-down parser, any recursion must be right recursion</li>\n<li>We would like to convert the left recursion to right recursion</li>\n</ul>\n<p><strong>Non-termination is a bad property in any part of a compiler</strong></p>\n<h4>Eliminating Left Recursion</h4>\n<p>To remove left recursion, we can transform the grammar</p>\n<p>Consider a grammar fragment of the form</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Fee -> Fee ğ°\n     | ğ±</code></pre></div>\n<p>where neither ğ° nor ğ± start with <em>Fee</em></p>\n<p>We can rewrite this as</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Fee -> ğ± Fie\nFie -> ğ° Fie\n     | ğ´</code></pre></div>\n<p>where <em>Fie</em> is a new non-terminal</p>\n<p><strong>This accepts the same language, but uses only right recursion</strong></p>\n<h2>Roadmap (Where are we?)</h2>\n<p>We set out to study parsing</p>\n<ul>\n<li>Specifying syntax\n<ul>\n<li>Context free grammars</li>\n<li>Ambiguity</li>\n</ul>\n</li>\n<li>Top-down parsers\n<ul>\n<li>Algorithm &#x26; its problem with left recursion</li>\n<li>Left-recursion removal</li>\n<li>Left factoring (will discuss later)</li>\n</ul>\n</li>\n<li>Predictive top-down parsing\n<ul>\n<li>The LL(1) condition</li>\n<li>Table-driven LL(1) parsers</li>\n<li>Recursive descent parsers\n<ul>\n<li>Syntax directed translation (example)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Picking the â€œRightâ€ production</h3>\n<p><strong>If it picks the wrong production, a top-down parser may backtrack. Alternative is to look ahead in input &#x26; use context to pick correctly</strong></p>\n<p>How much look ahead is needed?</p>\n<ul>\n<li>In general, an arbitrarily large amount</li>\n<li>Use the Cocke-Younger, Kasami algorithm or Earleyâ€™s algorithm</li>\n</ul>\n<p>Fortunately</p>\n<ul>\n<li>Large subclasses of CFGs can be parsed with limited look ahead</li>\n<li>Most programming language constructs fall in those subclasses</li>\n</ul>\n<p>Among the interesting subclasses are <em>LL(1)</em> and <em>LR(1)</em> grammars</p>\n<h2>Predictive Parsing</h2>\n<p>Basic idea\nGiven A -> ğ° | ğ±, the parser should be able to choose between ğ° and ğ±</p>\n<p>FIRST Sets</p>\n<ul>\n<li>For some rhs ğ° âˆˆ G, define <strong>FIRST(ğ°)</strong> as the set of tokens that appear as the first symbol in some string that derives from ğ°</li>\n<li>That is, a âˆˆ FIRST(ğ°) iff a =>^* ağ², for some ğ²</li>\n</ul>\n<p>The LL(1) property\nIf A -> ğ° and A -> ğ± both appear in the grammar, we would like <em>FIRST(ğ°) âˆ© FIRST(ğ±) = âˆ…</em></p>\n<ul>\n<li>Note: This is <em>almost</em> correct, but not quite!</li>\n</ul>\n<p>This would allow the parser to make a correct choice with a look ahead of exactly one symbol!</p>\n<h3>The FIRST Set - 1 Symbol Look ahead</h3>\n<p><img src=\"https://i.gyazo.com/fc09b7d26c594a3c2d60bc1d31165440.png\" alt=\"\"></p>\n<h3>The FOLLOW Set - 1 Symbol</h3>\n<p>For a non-terminal A, define FOLLOW(A) as</p>\n<p><em>FOLLOW(A) := the set of terminals that can appear immediately to the right of A in some sentential form</em></p>\n<p>Thus, a non-terminalâ€™s FOLLOW set specifies the tokens that can legally appear after it; a terminal has no FOLLOW set</p>\n<p><em>FOLLOW(A) = { a âˆˆ (T âˆª {eof}) | S eof =>^* ğ° A a ğ² }</em></p>\n<p>To build FOLLOW(X) for all non-terminal X</p>\n<ol>\n<li>Place eof in FOLLOW(&#x3C;goal>)</li>\n</ol>\n<ul>\n<li>Iterate until no more terminals or eof can be added to any FOLLOW(X)</li>\n</ul>\n<ol start=\"2\">\n<li>If A -> ğ°Bğ± then put {FIRST(ğ±) - ğ´} in FOLLOW(B)</li>\n<li>If A -> ğ°B then put FOLLOW(A) in FOLLOW(B)</li>\n<li>If A -> ğ°Bğ± and ğ´ âˆˆ FIRST(ğ±) then put FOLLOW(A) in FOLLOW(B)</li>\n</ol>\n<p>If A -> ğ° and A -> ğ± and ğ´ âˆˆ FIRST(ğ°), then we need to ensure that FIRST(ğ±) is disjoint from FOLLOW(A), too</p>\n<p><img src=\"https://i.gyazo.com/ab0480e11752f40f10fed1f3983f3c9e.png\" alt=\"\"></p>","frontmatter":{"date":"March 07, 2021","slug":"/compilers/lecture-13","title":"Compilers - Lecture 13"}}},"pageContext":{"id":"6b28c711-609b-5410-a8ac-65535bce0f52","frontmatter__slug":"/compilers/lecture-13","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}