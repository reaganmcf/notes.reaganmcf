{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-9/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 9</h1>\n<h2>Parser</h2>\n<h3>The Big Picture</h3>\n<ul>\n<li>Language syntax is specified over parts of <em>speech</em> (tokens)</li>\n<li>Syntax checking matches <em>sequence of tokens</em> against a grammar</li>\n<li>Here is an example of context free grammar (CFG) <em>G</em>.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. goal -> expr\n2. expr -> expr op term\n3.       | term\n4. term -> number\n5.       | id\n6. op   -> +\n7.       | -</code></pre></div>\n<p><em>G</em> in BNF form</p>\n<p>Math form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">S = goal\nT = { number, id, +, - }\nN = { goal, expr, term, op }\nP = { 1, 2, 3, 4, 5, 6, 7 }</code></pre></div>\n<h2>Scanner - Big Picture</h2>\n<p>Why study lexical analysis?</p>\n<ul>\n<li>We want to avoid writing scanners by hand</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/957d292a50325b8229779f7ea44108cc.png\" alt=\"\"></p>\n<p>Goals:</p>\n<ul>\n<li>To simplify specification &#x26; implementation of scanners</li>\n<li>To understand the underlying techniques and technologies</li>\n</ul>\n<h2>Regular Expressions</h2>\n<ul>\n<li>Σ = {a, b, c}\n<ul>\n<li>Alphabet, finite set of symbols</li>\n</ul>\n</li>\n</ul>\n<h3>Syntax vs. Semantics</h3>\n<table>\n<thead>\n<tr>\n<th>Syntax - Regular Expressions</th>\n<th>Semantics</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ϵ</td>\n<td>{ ϵ }</td>\n</tr>\n<tr>\n<td>a</td>\n<td>{ a }</td>\n</tr>\n<tr>\n<td>---</td>\n<td>—</td>\n</tr>\n<tr>\n<td>r1r2</td>\n<td>{ w1, w2 | w1 ∈ L(r1), w2 ∈ L(r2) }</td>\n</tr>\n<tr>\n<td>r1 | r2</td>\n<td>{w | w ∈ L(r1) or w ∈ L(r2) }</td>\n</tr>\n<tr>\n<td>r*</td>\n<td>∪(i =0, ∞) Li(r)</td>\n</tr>\n<tr>\n<td>r2+</td>\n<td>∪(i =1, ∞) Li(r)</td>\n</tr>\n</tbody>\n</table>\n<h4>Example 1</h4>\n<p><code class=\"language-text\">a(b|c)</code></p>\n<p>a = { a }\nb = { b }\nc = { c }\nb | c = { b, c }\na ( b | c ) = { ab, ac }</p>\n<h3>The Point</h3>\n<p>Regular expressions can be used to specify words to be translated to parts of speech (tokens) by a lexical analyzer</p>\n<p>Using results from automata theory and theory algorithms, we can automatically build recognizers from regular expressions</p>\n<p>=> We study REs and associated theory to automate scanner construction!</p>\n<h3>Example 2</h3>\n<p>Consider the problem of recognizing ILOC register names\n<code class=\"language-text\">Register -> r (0|1|2|...|9) (0|1|2|...|9)*</code></p>\n<ul>\n<li>Allows registers of arbitrary number</li>\n<li>Requires at least one digit</li>\n</ul>\n<p>RE corresponds to a recognizer (or DFA)</p>\n<p><img src=\"https://i.gyazo.com/555fe1e3748da68b09bb16f53a14ea2e.png\" alt=\"\"></p>\n<p>DFA Operation</p>\n<ul>\n<li>Start in state s0 &#x26; take transitions on each input character</li>\n<li>DFA accepts a word <em>x</em> if and only if <em>x</em> leaves it in a final state (s2)</li>\n</ul>\n<p>So,</p>\n<ul>\n<li>r17 takes it through s0, s1, s2 and accepts</li>\n<li>r takes it through s0, s1, and fails</li>\n<li>a takes it straight to error state se (not shown here)</li>\n</ul>\n<p>To be useful, recognizer must turn into code</p>\n<p><img src=\"https://i.gyazo.com/09aaa06fd321933cd2b3adb0515b5ca6.png\" alt=\"\"></p>","frontmatter":{"date":"February 16, 2021","slug":"/compilers/lecture-9","title":"Compilers - Lecture 9"}}},"pageContext":{"id":"415cc4e2-3c5c-5535-a39c-fd1b5d86f515","frontmatter__slug":"/compilers/lecture-9","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}