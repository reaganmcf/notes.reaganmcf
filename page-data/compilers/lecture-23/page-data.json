{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-23/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 23 - Procedure Abstraction</h1>\n<h2>The Procedure: 3 Abstractions</h2>\n<ul>\n<li><strong>Control</strong> abstraction\n<ul>\n<li>Well defined entries &#x26; exits</li>\n<li>Mechanism to return control to caller</li>\n<li>Some notion of parameterization (usually)</li>\n</ul>\n</li>\n<li>Clean <strong>Name Space</strong>\n<ul>\n<li>Clean state for writing locally visible names</li>\n<li>Local names may obscure identical, non-local names</li>\n<li>Local names cannot be seen outside</li>\n</ul>\n</li>\n<li>External <strong>Interface</strong>\n<ul>\n<li>Access is by procedure name &#x26; parameters</li>\n<li>Clear protection for both caller &#x26; callee</li>\n</ul>\n</li>\n<li>Procedures permit a critical separation of concerns</li>\n</ul>\n<h3>The Procedure (Realist’s View)</h3>\n<p>Procedures allow us to <strong>separate compilation</strong></p>\n<ul>\n<li>Separate compilation allows us to build non-trivial programs</li>\n<li>Keeps compile times reasonable</li>\n<li>Lets multiple programmers collaborate</li>\n<li>Requires independent procedures</li>\n</ul>\n<p>Without separate compilation, we <em>would not</em> build large systems</p>\n<p>The procedure <strong>linkage convention</strong></p>\n<ul>\n<li>Ensures that each procedure inherits a valid run-time environment and that the callers environment is restored on return\n<ul>\n<li>The compiler must generate code to ensure this happens according to conventions established by the system</li>\n</ul>\n</li>\n</ul>\n<h3>The Procedure (More Abstract View)</h3>\n<p><strong>A procedure is an abstract structure constructed via software</strong></p>\n<p>Underlying hardware directly supports little of the abstraction - it understands bits, bytes, integers, reals, and addresses, but not</p>\n<ul>\n<li>Entries and exits</li>\n<li>Interfaces</li>\n<li>Call and return mechanisms\n<ul>\n<li>May be a special instruction to save context at point of call</li>\n</ul>\n</li>\n<li>Name space</li>\n<li>Nested scopes</li>\n</ul>\n<p>All these are established by a carefully-crafted system of mechanisms provided by compiler, run-time system, linkage editor and loader, and OS</p>\n<h3>Run Time vs. Compile Time</h3>\n<p>These concepts are often confusing</p>\n<ul>\n<li>The procedure linkages execute at <strong>run time</strong></li>\n<li>Code for the procedure linkage is emitted at <strong>compile time</strong></li>\n<li>The procedure linkage is designed long before either of these</li>\n</ul>\n<h3>The Procedure as a Control Abstraction</h3>\n<p>Procedures have well-defined control-flow</p>\n<p>The Algol-60 procedure call</p>\n<ul>\n<li>Invoked at a call site, with some set of <em>actual parameters</em></li>\n<li>Control returns to call site, immediately after invocation</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/92e1f3957708af645f121ffeef4e9700.png\" alt=\"\"></p>\n<ul>\n<li>Most languages allow recursion</li>\n</ul>\n<p>Implementing procedures with this behavior</p>\n<ul>\n<li>Requires code to <strong>save</strong> and <strong>restore</strong> a “return address”</li>\n<li>Must map <strong>actual parameters</strong> to <strong>formal parameters</strong></li>\n<li>Must create storage for <strong>local variables</strong> (any, maybe, parameters)\n<ul>\n<li><em>p</em> needs space for <em>d</em> (and, maybe, <em>a</em>, <em>b</em>, and <em>c</em>)</li>\n<li>where does this space go in recursive invocations?</li>\n</ul>\n</li>\n<li>Must preserve <em>p</em>’s <strong>state</strong> while <em>q</em> executes\n<ul>\n<li>Recursion causes the real problem here</li>\n</ul>\n</li>\n<li>Strategy: Create unique location for each procedure <strong>activation</strong>\n<ul>\n<li>Can use a “stack” of memory blocks to hold local storage and return addresses</li>\n</ul>\n</li>\n<li>Compiler <em>emits</em> code that causes all this to happen at run time</li>\n</ul>\n<h3>The Procedure as a Name Space</h3>\n<p>Each procedure creates its own name space</p>\n<ul>\n<li>Any name (almost) can be declared locally</li>\n<li>Local names obscure identical non-local names</li>\n<li>Local names cannot be seen outside the procedure\n<ul>\n<li>Nested procedures are “inside” by definition</li>\n</ul>\n</li>\n<li>We call this set of rules &#x26; conventions <strong>“lexical scoping”</strong></li>\n</ul>\n<p>Examples:</p>\n<ul>\n<li>C has global, static, local, and <em>block</em> scopes\n<ul>\n<li>Blocks can be nested, procedures cannot</li>\n</ul>\n</li>\n<li>Scheme has global, procedure-wide, and nested scopes\n<ul>\n<li>Procedure scope (typically) contains format parameters</li>\n</ul>\n</li>\n</ul>\n<p>Why introduce lexical scoping?</p>\n<ul>\n<li>Provides a compile-time mechanism for binding “free” variables</li>\n<li>Simplifies rules for naming &#x26; resolves conflicts</li>\n<li>How can the compiler keep track of all those names?</li>\n</ul>\n<p>The Problem</p>\n<ul>\n<li>At point <em>p</em>, which declaration of <em>x</em> is current?</li>\n<li>At run-time, where is <em>x</em> found?</li>\n<li>As parser goes in &#x26; out of scopes, how does it delete <em>x</em>?</li>\n</ul>\n<p>The answer:</p>\n<ul>\n<li>Lexically scoped symbol tables</li>\n</ul>\n<h4>Where do all these variables go?</h4>\n<ul>\n<li>Automatic &#x26; Local\n<ul>\n<li>Keep them in the procedure activation record or in a register</li>\n<li>Automatic => lifetime matches procedure’s lifetime</li>\n</ul>\n</li>\n<li>Static\n<ul>\n<li>Procedure scope => storage area affixed with procedure name</li>\n<li>File scope => storage area affixed with file name</li>\n<li>Lifetime is entire execution</li>\n</ul>\n</li>\n<li>Global\n<ul>\n<li>One or more global data areas</li>\n<li>One per program</li>\n<li>Lifetime is entire execution</li>\n</ul>\n</li>\n</ul>\n<h4>Placing Run-time Data Structure</h4>\n<p><img src=\"https://i.gyazo.com/f9caa209c9c99d5185f6d4f12469d0bc.png\" alt=\"\"></p>\n<ul>\n<li>Code, static, and global data have known size</li>\n<li>Heap and stack both grow &#x26; shrink over time</li>\n<li>This is a <strong>virtual</strong> address space</li>\n</ul>\n<h2>Activation Record Basics</h2>\n<p><img src=\"https://i.gyazo.com/92a13b359aaf1283189fea44b96334a0.png\" alt=\"\"></p>","frontmatter":{"date":"April 20, 2021","slug":"/compilers/lecture-23","title":"Compilers - Lecture 23"}}},"pageContext":{"id":"63bdeead-7935-54dd-958c-7e8927527669","frontmatter__slug":"/compilers/lecture-23","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}