{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-22/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 22 - Compiler Optimizations</h1>\n<h2>Code Improvement</h2>\n<ul>\n<li>Analyzes IR and rewrites (or <em>transforms</em>) IR</li>\n<li>Primary goal is to reduce running time of the compiled code\n<ul>\n<li>May also improve space, power dissipation, energy consumption</li>\n</ul>\n</li>\n<li>Must preserve “meaning” of the code (may include approximations, i.e., quality of outcomes and trade-offs)\n<ul>\n<li>Measured by values of named variables or produced output</li>\n</ul>\n</li>\n</ul>\n<h2>The Optimizer (or Middle End)</h2>\n<blockquote>\n<p>Modern optimizers are structured as a series of passes</p>\n</blockquote>\n<p>Typical transformations</p>\n<ul>\n<li>Discover &#x26; propagate some constant value</li>\n<li>Move a computation to a less frequently executed place</li>\n<li>Specialize some computation based on context</li>\n<li>Discover a redundant computation and remove it</li>\n<li>Remove useless or unreachable code</li>\n<li>Encode an idiom in some particularly efficient form</li>\n</ul>\n<h3>Benefits</h3>\n<p>How to assess any technique (transformation) that will improve the overall program outcome or its (dynamic) execution</p>\n<ul>\n<li>(S) - Safety\n<ul>\n<li>Program semantics has to be preserved (true or false)</li>\n</ul>\n</li>\n<li>(O) - Opportunity\n<ul>\n<li>How often can the optimization be safely applied during the execution of the program (percentage)</li>\n</ul>\n</li>\n<li>(P) - Profitability\n<ul>\n<li>If the optimization is applied, what is the expected average benefit in terms of the target metric?</li>\n</ul>\n</li>\n</ul>\n<p>Benefit = [(100 - O) + O/P] if S = true</p>\n<p>Examples:</p>\n<ul>\n<li>The transformation “a” is safe and improves the execution time of 10% of the executed code by a factor of 5\n<ul>\n<li>Benefit: execution time reduced to 92%</li>\n</ul>\n</li>\n<li>The transformation “b” is not safe and improves the execution time 40% of the executed code by a factor of 2\n<ul>\n<li>Benefit is not defined</li>\n<li>If “b” were safe, benefit: execution time reduced to 80%</li>\n</ul>\n</li>\n</ul>\n<h3>Interactions</h3>\n<p>How do these optimizations interact?</p>\n<p>A significant body of research tries to find the best sequence of optimizing transformations for different application domains. These transformations are not Church-Rosser, i.e., the particular order of these transformations impact the overall ooutcome.</p>\n<p>Some of the optimizations are used as “clean-up” passes (e.g.: constant propagation, dead code elimination). This allows implementers of other transformations to use simpler algorithms and data abstractions that are easier to reason about.</p>\n<p>When you decide an optimization pass, keep in mind that the program your optimizing pass is presented with may have run through many previous transformations, significantly changing the program’s code shape. Most likely, this code shape would not have been generated directly by any human programmer. Make sure your optimization path algorithms and data structures can deal with “un-natural” shapes.</p>\n<h3>Commonality</h3>\n<p>What do these optimizations have in common?</p>\n<ul>\n<li>Their goal is to reduce the number of machine cycles needed to execute the program (<strong>reduce dynamic execution count</strong>)</li>\n</ul>\n<p>Note: reducing dynamic execution cycles does not always imply reducing static program size. In fact, many optimizations increase the program size significantly. This in turn can have negative impact on (dynamic) performance (e.g.: caches, failure of “standard” algorithms to generate good code).</p>\n<p>Examples:</p>\n<ul>\n<li>Procedure in-lining</li>\n<li>Blocking for memory hierarchy</li>\n<li>Loop unrolling to increase basic block size</li>\n</ul>\n<h3>Optimization Goals</h3>\n<p>What other optimization goals are there?</p>\n<ul>\n<li>Performance</li>\n<li>Size of executable</li>\n<li>Power</li>\n<li>Energy</li>\n<li>Thermal</li>\n</ul>\n<p>How do these different optimization goals interact</p>\n<ul>\n<li>Does one optimization goal subsumes another, or are they all different?</li>\n<li>Can one optimization goal conflict with another?\n<ul>\n<li>(e.g.: power vs. performance, thermal vs. performance)</li>\n</ul>\n</li>\n</ul>\n<h3>Scope / Granularity</h3>\n<p>Example: Discover and propagate some constant values (constant folding / propagation)</p>\n<p>Local, global (intra-procedural), and inter-procedural optimization</p>\n<h4>Local</h4>\n<p>Local: Basic block within a procedure</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a := 2\nb := 3\nc := a + b\nprint(c)</code></pre></div>\n<p>This get’s optimized to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a := 2\nb := 3\nc := 5\nprint(5)</code></pre></div>\n<h4>Global</h4>\n<p>Global: Control flow between basic blocks within a procedure</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (...) then {\n  a := 2\n  b := 3\n} else {\n  a := 3\n  b := 2\n}\nc := a + b\nprint(c)</code></pre></div>\n<p>This gets optimized to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (...) then {\n  a := 2\n  b := 3\n} else {\n  a := 3\n  b := 2\n}\n\nc := 5\nprint(5)</code></pre></div>\n<h4>Inter-procedural</h4>\n<p>Inter-procedural: Control flow across procedure calls</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">procedure foo(a,b) {\n  c := a + b // no side effects\n  return c;\n}\n\nprocedure bar() {\n  ...\n  c := foo(2, 3)\n  print(c)\n\n  d := foo(5,5)\n  print(d)\n}</code></pre></div>\n<p>This gets optimized to</p>","frontmatter":{"date":"April 18, 2021","slug":"/compilers/lecture-22","title":"Compilers - Lecture 22"}}},"pageContext":{"id":"bb63c8fe-c891-54c5-b9e8-91ff34027cc3","frontmatter__slug":"/compilers/lecture-22","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}