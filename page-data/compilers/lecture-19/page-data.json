{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-19/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 19 - Type systems</h1>\n<h2>Types and Type Systems</h2>\n<p>Type: A set of values and meaningful operations on them</p>\n<p>Types provide semantic â€œsanity checksâ€ and determine efficient implementations for data objects</p>\n<p>Types help identify</p>\n<ul>\n<li>Errors\n<ul>\n<li>Dereferencing a non-pointer</li>\n<li>Adding a function to something</li>\n<li>Incorrect number of parameters to a procedure</li>\n</ul>\n</li>\n<li>Which operation to use for overloaded names and operators, or what type of type coercion to use (e.g.: 3.0 + 1)</li>\n<li>Identification of polymorphic functions</li>\n</ul>\n<h3>Type System</h3>\n<p>Type system: Each language construct (operator, expression, statement, â€¦) is associated with a <strong>type expression</strong>. The type system is a collection of rules for assigning <strong>type expressions</strong> to these constructs</p>\n<p>Type expressions for:</p>\n<ul>\n<li>Basic types: <code class=\"language-text\">integer</code>, <code class=\"language-text\">char</code>, <code class=\"language-text\">real</code>, <code class=\"language-text\">boolean</code>, <code class=\"language-text\">typeError</code></li>\n<li>Constructed types, e.g., one-dimensional arrays: <code class=\"language-text\">array(lb, ub, elem_type)</code>, where elem_type is a <strong>type expression</strong></li>\n</ul>\n<p>A <strong>type checker</strong> implements a type system. It computes or â€œconstructsâ€ type expressions for each language construct.</p>\n<h3>Inference rules</h3>\n<p>Example type inference rule:</p>\n<p>E âŠ¢ e1 : integer, E âŠ¢ e2 : integer => E âŠ¢ e1 + e2 : integer</p>\n<p>Where E is a type environment that maps constants and variables to their type expressions</p>\n<h3>Example</h3>\n<p>Letâ€™s say we have the expression <code class=\"language-text\">1 + 5</code>.</p>\n<p>We can describe our E as E = {1 : integer, 5 : integer}</p>\n<p>We also have the following inference rules (that are fairly trivial)</p>\n<ul>\n<li>E = {1 : integer, 5 : integer} âŠ¢ 1 : integer</li>\n<li>E = {1 : integer, 5 : integer} âŠ¢ 5 : integer</li>\n</ul>\n<p>This means that we also have the following inference rule</p>\n<p>E âŠ¢ 1 : integer, E âŠ¢ 5 : integer => E âŠ¢ 1 + 5 : integer</p>\n<h3>Polymorphic example</h3>\n<p>What would the type of dereferencing a pointer?</p>\n<ul>\n<li>E âŠ¢ e1 : pointer (ğ›‚) => E âŠ¢ * e1 : ğ›‚</li>\n<li>ğ›‚ is any type expression</li>\n</ul>\n<p>What would be the type of referencing a value?</p>\n<ul>\n<li>E âŠ¢ e1 : ğ›‚ => E âŠ¢ &#x26; e1 : pointer (ğ›‚)</li>\n<li>ğ›‚ is any type expression</li>\n</ul>\n<h3>More complicated example</h3>\n<p>Letâ€™s say we have the following expression <code class=\"language-text\">*(&amp;a)+3</code>, and E starts off as E = {3 : integer}</p>\n<ol>\n<li>We donâ€™t know what type <code class=\"language-text\">a</code> is, so letâ€™s just call it ğ›ƒ\n<ul>\n<li>E = {3 : integer, a : ğ›ƒ }</li>\n</ul>\n</li>\n<li>Using the inference rule E âŠ¢ e1 : ğ›‚ => E âŠ¢ &#x26;e1 : pointer(ğ›‚), we know that E âŠ¢ (&#x26;a) : pointer(ğ›ƒ)</li>\n<li>Using the inference rule E âŠ¢ e1 : pointer (ğ›‚) => E âŠ¢ * e1 : ğ›‚, we know that E âŠ¢ *(&#x26;a) : ğ›ƒ</li>\n<li>Since our addition rule <strong>only works with integers</strong>, using the inference rule E âŠ¢ *(&#x26;a) : ğ›ƒ, E âŠ¢ 3 : integer => E âŠ¢ *(&#x26;a)+3 : integer\n<ul>\n<li>E = {3 : integer, a : ğ›ƒ, ğ›ƒ : integer}</li>\n<li>Which also means that E âŠ¢ a : integer since E âŠ¢ ğ›ƒ : integer</li>\n</ul>\n</li>\n</ol>\n<h2>Type Equivalence</h2>\n<p><strong>Structural</strong> type equivalence: <em>type names</em> are expanded\n<strong>Name</strong> type equivalence: <em>type names</em> are not expanded</p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type A is array(1..10) of integer;\ntype B is array(1..10) of integer;\na: A;\nb: B;\nc, d: array(1..10) of integer;\ne: array(1..10) of integer;</code></pre></div>\n<p>Are a,b,c,d,e the same type?</p>\n<ul>\n<li>For <strong>structural type equivalence they are equivalent</strong></li>\n<li>For <strong>name equivalence</strong>, a and b are different, while c,d,e are equivalent</li>\n</ul>\n<p>Project 2 hint:</p>\n<p>The definition of type expression as C types (structs) should be done in attr.h. attr.c may contain helper functions\nThe assignment of type expression C types to terminals and nonterminals of the grammar is done in parse.y</p>\n<h3>Lexically-scoped Symbol Tables</h3>\n<p>The problem</p>\n<ul>\n<li>The compiler needs a distinct record for each declaration</li>\n<li>Nested lexical scopes admit duplicate declarations</li>\n</ul>\n<p>The interface</p>\n<ul>\n<li><code class=\"language-text\">insert(name, level)</code> creates a record for <code class=\"language-text\">name</code> at <code class=\"language-text\">level</code></li>\n<li><code class=\"language-text\">lookup(name, level)</code> returns pointer or index</li>\n<li><code class=\"language-text\">delete(level)</code> removes all names declared at <code class=\"language-text\">level</code></li>\n</ul>\n<p>Many implementation schemes have been proposed</p>\n<ul>\n<li>Weâ€™ll stay at the conceptual level</li>\n<li>Hash table implementation is tricky, detailed, &#x26; fun</li>\n</ul>","frontmatter":{"date":"April 04, 2021","slug":"/compilers/lecture-19","title":"Compilers - Lecture 19"}}},"pageContext":{"id":"43ecbfa7-0bf9-52b0-a5fa-835b09f9c839","frontmatter__slug":"/compilers/lecture-19","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}