{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-21/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 21 - Code Generation Continued and IR</h1>\n<h2>Boolean and Relational Values</h2>\n<p>How should the compiler represent them?</p>\n<ul>\n<li>Answer depends on the target machine</li>\n</ul>\n<p>Two classical approaches</p>\n<ul>\n<li>Numerical representation</li>\n<li>Positional (implicit) representation</li>\n</ul>\n<p>Correct choice depends on both context and ISA</p>\n<p>Examples:</p>\n<ul>\n<li><code class=\"language-text\">x &lt; y</code> -> <code class=\"language-text\">cmp_LT rx, ry => r1</code></li>\n</ul>\n<p>What if the ISA uses a condition code?</p>\n<ul>\n<li>Must use a conditional branch to interpret result of compare</li>\n<li>Necessitates branches in the evaluation</li>\n</ul>\n<p>Example: <code class=\"language-text\">r2</code> should contain boolean value of <code class=\"language-text\">x &lt; y</code> evaluation</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cmp rx, ry => cc1\ncbr_LT cc1 => LT, LF\nLT: loadI 1 => r2\n    br => LOUT\nLF: loadI 0 => r2\nLOUT: ...</code></pre></div>\n<h2>Intermediate Representation</h2>\n<ul>\n<li>Front end produces an IR</li>\n<li>Middle end transforms the IR into an equivalent IR that runs more efficiently</li>\n<li>Back end transforms the IR into native code</li>\n<li>IR encodes the compiler’s knowledge of the program</li>\n<li>Middle end usually consists of several passes</li>\n</ul>\n<h3>Choosing an IR</h3>\n<ul>\n<li>Decisions in IR design affect the speed and efficiency of the compiler</li>\n<li>Some important IR properties\n<ul>\n<li>Ease of generation</li>\n<li>Ease of manipulation</li>\n<li>Size</li>\n<li>Level of abstraction</li>\n</ul>\n</li>\n<li>The importance of different properties varies between compilers\n<ul>\n<li>Selecting an appropriate IR for a compiler is critical</li>\n</ul>\n</li>\n</ul>\n<h3>Types of IR</h3>\n<p>Three major categories</p>\n<ol>\n<li>Structural</li>\n</ol>\n<ul>\n<li>Graphically oriented</li>\n<li>Heavily used in source-to-source translation</li>\n<li>Tend to be large</li>\n<li>Examples: Trees and DAGs</li>\n</ul>\n<ol start=\"2\">\n<li>Linear</li>\n</ol>\n<ul>\n<li>Pseudo-code for an abstract machine</li>\n<li>Level of abstraction varies</li>\n<li>Simple, compact data structures</li>\n<li>Easier to rearrange</li>\n<li>Examples: 3 address code, stack machine code</li>\n</ul>\n<ol start=\"3\">\n<li>Hybrid</li>\n</ol>\n<ul>\n<li>Combination of graphs and linear code</li>\n<li>Example: Control-flow graph</li>\n</ul>\n<h3>Level of Abstraction</h3>\n<ul>\n<li>The level of detail exposed in an IR influences the profitability and feasibility of different optimizations</li>\n<li>Two different representations of an array reference\n<ul>\n<li>an AST array reference is much easier to comprehend and optimize than a linear code stream</li>\n</ul>\n</li>\n<li>Level of granularity is up to the designer</li>\n</ul>\n<h2>AST</h2>\n<p>An abstract syntax tree is the procedure’s parse tree with the nodes for most non-terminal nodes removed</p>\n<ul>\n<li>Can use linearized form of the tree\n<ul>\n<li><code class=\"language-text\">x 2 y * -</code></li>\n<li><code class=\"language-text\">- * 2 y x</code></li>\n</ul>\n</li>\n</ul>\n<h2>Stack Machine Code</h2>\n<p>Originally used for stack-based computers, now Java</p>\n<ul>\n<li>Example: <code class=\"language-text\">x - 2 * y</code> becomes</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">push x\npush 2\npush y\nmultiply\nsubtract</code></pre></div>\n<p>Advantages:</p>\n<ul>\n<li>Compact form</li>\n<li>Introduced names are <em>implicit</em>, not <em>explicit</em></li>\n<li>Simple to generate and execute code</li>\n</ul>\n<p>Useful where code is transmitted over slow communication links (like the Internet)</p>\n<h2>Control Flow Graph</h2>\n<p>Models the transfer of control in the procedure</p>\n<ul>\n<li>Nodes in the graph are basic blocks\n<ul>\n<li>Can be represented with quads or any other linear representation</li>\n<li>Edges in the graph represent control flow</li>\n</ul>\n</li>\n</ul>\n<h2>Static Single Assignment Form (SSA)</h2>\n<ul>\n<li>The main idea: each name defined exactly once in program</li>\n<li>Introduce Φ-functions to make it work</li>\n</ul>\n<p>Original:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x &lt;- ...\ny &lt;- ...\nwhile (x &lt; k)\n  x &lt;- x + 1\n  y &lt;- y + x</code></pre></div>\n<p>SSA Form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      x0 &lt;- ...\n      y0 &lt;- ...\n      if (x0 > k) goto next\nloop: x1 &lt;- Φ(x0, x2)\n      y1 &lt;- Φ(x0, y2)\n      x2 &lt;- x1 + 1\n      y2 &lt;- y1 + x2\n      if (x2 &lt; k) goto loop\nnext: ...</code></pre></div>\n<p>Strengths of SSA form:</p>\n<ul>\n<li>Sharper analysis</li>\n<li>“minimal” Φ-functions placement is non-trivial</li>\n<li>(sometimes) faster algorithms</li>\n</ul>","frontmatter":{"date":"April 13, 2021","slug":"/compilers/lecture-21","title":"Compilers - Lecture 21"}}},"pageContext":{"id":"7aded67b-333d-50f8-9c3b-adfaaff4f5c7","frontmatter__slug":"/compilers/lecture-21","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}