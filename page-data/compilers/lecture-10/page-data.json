{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-10/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 10</h1>\n<h2>Constructing a Scanner - Quick Review</h2>\n<p><img src=\"https://i.gyazo.com/33e0307e32cf3e6cf9a375869cd6eacb.png\" alt=\"\"></p>\n<ul>\n<li>The scanner is the first stage in the front end</li>\n<li>Specifications can be expressed using regular expressions</li>\n<li>Build tables and code from a DFA</li>\n</ul>\n<h2>Goal</h2>\n<ul>\n<li>We will show how to construct a finite state automata to recognize any RE</li>\n<li>Overview:\n<ul>\n<li>Direct construction of a <strong>nondeterministic finite automata (NFA)</strong> to recognize a given RE\n<ul>\n<li>Requires ε-transitions to combine regular subexpressions</li>\n</ul>\n</li>\n<li>Construct a <strong>deterministic finite automata (DFA)</strong> to simulate the NFA\n<ul>\n<li>Use a set-of-states construction</li>\n</ul>\n</li>\n<li>Generate the scanner code\n<ul>\n<li>Additional specifications needed for details</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>NFAs</h3>\n<ul>\n<li>An NFA accepts a string x iff ∃ a path through the transition graph from s0 to a final state such that the edge labels spell x</li>\n<li>Transitions on ε consume no input</li>\n<li>To “run” the NFA, start in s0 and <em>guess</em> the right transition at each step\n<ul>\n<li>Always guess correctly</li>\n<li>If some sequence of correct guesses accepts x then accept</li>\n</ul>\n</li>\n</ul>\n<p>Why study NFAs?</p>\n<ul>\n<li>They are they key to automating the RE -> DFA construction</li>\n<li>We can paste together NFAs with ε transitions</li>\n</ul>\n<h3>Relationship between NFAs and DFAs</h3>\n<p>DFA is a special case of an NFA</p>\n<ul>\n<li>DFA has no ε transitions</li>\n<li>DFA’s transition function is single-valued</li>\n<li>Same rules will work</li>\n</ul>\n<p>DFA can be simulated with an NFA</p>\n<ul>\n<li>Obviously</li>\n</ul>\n<p>NFA can be simulated with a DFA</p>\n<ul>\n<li>Less obvious</li>\n<li>Simulate sets of possible states</li>\n<li>Possible exponential blowup in the state space</li>\n<li>Still, one state transition per character in the input stream</li>\n</ul>\n<h2>Automating Scanner Construction</h2>\n<p>To convert a specification into code:</p>\n<ol>\n<li>Write down the RE for the input language</li>\n<li>Build a big NFA</li>\n<li>Build the DFA that simulates the NFA</li>\n<li>Systematically shrink the DFA</li>\n<li>Turn it into code</li>\n</ol>\n<p>Scanner generators</p>\n<ul>\n<li>Lex and Flex work along these lines</li>\n<li>Algorithms are well known and well understood</li>\n<li>Key issue is interface to parser</li>\n<li>You could build one in a weekend!</li>\n</ul>\n<p>RE -> NFA (Thompson’s construction)</p>\n<ul>\n<li>Build an NFA for each term</li>\n<li>Combine them with ε moves</li>\n</ul>\n<p>NFA -> DFA (subset construction)</p>\n<ul>\n<li>Build the simulation</li>\n</ul>\n<p>DFA -> Minimal DFA</p>\n<ul>\n<li>Hopcroft’s algorithm</li>\n</ul>\n<p>DFA -> RE (Not part of the scanner construction)</p>\n<ul>\n<li>All pairs, all paths problem</li>\n<li>Take the union of all paths from s0 to an accepting state</li>\n</ul>\n<h3>RE -> NFA using Thomspon’s Construction</h3>\n<p>Key idea</p>\n<ul>\n<li>NFA pattern for each symbol and each operator</li>\n<li>Each NFA has a single start and accept state</li>\n<li>Join them with ε moves in precedence order</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/a6ab440bf0198b0ea0342fc59f7cb036.png\" alt=\"\"></p>\n<h5>Examples</h5>\n<p><img src=\"https://i.gyazo.com/d9656b923e86585aa1b1d9f426096700.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/5a4caf3f3d83ac9edbffb96b3c085ee6.png\" alt=\"\"></p>\n<h3>NFA -> DFA with Subset Construction</h3>\n<p>Need to build a simulation of the NFA</p>\n<p>Two key functions</p>\n<ul>\n<li><code class=\"language-text\">move(si, a)</code> is a set of states reachable from si by a</li>\n<li><code class=\"language-text\">ε-closure(si)</code> is the set of states reachable from si by ε</li>\n</ul>\n<p>The algorithm (sketch):</p>\n<ul>\n<li>Start state derived from s0 of the NFA</li>\n<li>Take its <code class=\"language-text\">ε-closure</code> S0 = <code class=\"language-text\">ε-closure(s0)</code></li>\n<li>For each state S, compute <code class=\"language-text\">move(S, a)</code> for each a ∈ Σ, and take it’s ε-closure</li>\n<li>Iterate until no more states are added</li>\n</ul>\n<p>Sounds more complex that it is…</p>\n<h4>Algorithm:</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">s0 &lt;- ε-closure(q0)\nadd s0 to S\nwhile (S is still changing)\n  for each si ∈ S\n    for each a ∈ Σ\n      s? &lt;- ε-closure(move(si, a))\n      if (s? ∉ S) then\n        add s? to S as sj\n        T[si, a] &lt;- sj\n      else\n        T[si, a] &lt;- s?</code></pre></div>\n<p>The algorithm halts:</p>\n<ol>\n<li>S contains no duplicates (test before adding)</li>\n<li>2^Q is finite</li>\n<li>while loop adds to S, but does not remove from S (monotone)\n=> the loop halts</li>\n</ol>\n<p>S contains all the reachable NFA states</p>\n<ul>\n<li>It tries each symbol in each si</li>\n<li>It builds every possible NFA configuration\n=> S and T form the DFA</li>\n</ul>\n<hr>\n<p>Example of a fixed-point computation</p>\n<ul>\n<li>Monotone construction of some finite set</li>\n<li>Halts when it stops adding to the set</li>\n<li>Proofs of halting &#x26; correctness are similar</li>\n<li>These computations arise in many contexts</li>\n</ul>\n<p>Other fixed-point computations</p>\n<ul>\n<li>Canonical construction of sets of LR(1) items\n<ul>\n<li>Quite similar to the subset construction</li>\n</ul>\n</li>\n<li>Classic data-flow analysis\n<ul>\n<li>Solving sets of simultaneous set equations</li>\n</ul>\n</li>\n<li>DFA minimization algorithm (coming up!)</li>\n</ul>\n<p><em>We will see many more fixed-point computations</em></p>\n<h4>Example</h4>\n<p><img src=\"https://i.gyazo.com/7732511a30a8b3a177675f5fcd986da1.png\" alt=\"\"></p>\n<p>Applying the subset construction</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a</th>\n<th>b</th>\n<th>c</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>{q0}</td>\n<td>{q1, q2 q3, q9, q4, q6 }</td>\n<td>none</td>\n<td>none</td>\n</tr>\n<tr>\n<td>{q1,q2,q3,q9,q4,q6}</td>\n<td>none</td>\n<td>{q5, q8, q3, q6, q4, q9}</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Finished in the next lecture…</p>","frontmatter":{"date":"February 21, 2021","slug":"/compilers/lecture-10","title":"Compilers - Lecture 10"}}},"pageContext":{"id":"00322eaf-d18c-55e1-83f9-ae1efafc9d0e","frontmatter__slug":"/compilers/lecture-10","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}