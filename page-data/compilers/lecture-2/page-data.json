{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-2/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 2</h1>\n<h2>Backend - Register Allocation</h2>\n<p><img src=\"https://i.gyazo.com/e52d0401830707dcf9a45fc69638d720.png\" alt=\"\"></p>\n<p>Critical properties:</p>\n<ul>\n<li>Produce correct code that uses <em>k</em> (or fewer) registers</li>\n<li>Minimize added loads and stores</li>\n<li>Minimize space used to hold <em>spilled values</em></li>\n<li>Operate efficiently: O(n), O(nlog2n), maybe O(n^2), but not O(2^n)</li>\n</ul>\n<h2>Instruction Scheduling</h2>\n<p><strong>Motivation</strong></p>\n<ul>\n<li>Instruction latency (pipelining)</li>\n<li>Several cycles to complete instructions; instructions can be issued every cycle</li>\n<li>Instruction level paralellelism (VLIW, superscalar)\n<ul>\n<li>Execute multiple instructions per cycle</li>\n</ul>\n</li>\n</ul>\n<p><strong>Issues</strong></p>\n<ul>\n<li>\n<p>Reorder instructions to reduce execution time</p>\n</li>\n<li>\n<p>Static schedule - insert NOPs to preserve correctness</p>\n</li>\n<li>\n<p>Dynamic schedule - hardware pipeline stalls</p>\n</li>\n<li>\n<p>Preserve correctness, improve performance</p>\n</li>\n<li>\n<p>Interactions with other optimizations (register allocation!)</p>\n</li>\n<li>\n<p>Note: <strong>After register allocation, code shape contains real, not virtual registers ==> register may be redefined</strong></p>\n</li>\n<li>\n<p>ILOC simulator “sim” is available on ilab at <code class=\"language-text\">~uli/cs415/ILOC_Simulator/sim</code></p>\n</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/fbc01135794dc3871d53123f3cdd5bf8.png\" alt=\"\"></p>\n<h3>Local Instruction Scheduling</h3>\n<p>Readings: EaC 12.1-12.3, Appendix A (ILOC)</p>\n<p>Definition: A <em>basic block</em> is a maximal length segment of straight line (i.e., <em>branch free</em>) code. Control can only enter at first instruction of basic block and exist after last instruction.</p>\n<p><strong>Local</strong>: within single basic block\n<strong>Global</strong>: across procedures/functions</p>\n<h2>ILOC (Intermediate Language for Optimizing Compilers)</h2>\n<p>Instruction scheduling on basic blocks in “ILOC”</p>\n<ul>\n<li>Pseudo-code for a simple, abstracted RISC machine\n<ul>\n<li>generated by the instruction selection process</li>\n</ul>\n</li>\n<li>Simple, conmpact data structures</li>\n<li>Here: we only use a small subset of ILOC</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/72c6966cf415479a32b41189433ecd35.png\" alt=\"\"></p>\n<ul>\n<li>ILOC simulator “sim” is available on ilab at <code class=\"language-text\">~uli/cs415/ILOC_Simulator/sim</code></li>\n</ul>\n<h3>Memory Model / Code Shape</h3>\n<ul>\n<li>Source code:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A = 5;\nB = 6;\nC = A + B;</code></pre></div>\n<p>Memory layout:\n<img src=\"https://i.gyazo.com/45be44fc477ba892be53f4d850d097ac.png\" alt=\"\"></p>\n<p>Assume A, B, C are integer values of 4 bytes</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">address(A) = 1024 + offset(A) = 1028\naddress(B) = 1024 + offset(B) = 1032\naddress(C) = 1024 + offset(C) = 1036</code></pre></div>\n<p>More generally: <code class=\"language-text\">address(X) = base_address + offset(X)</code></p>\n<p>This convention is used in activation records or stack frames. We use it here for consistency</p>\n<p>ILOC Code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loadI 5 => r1\n// compute address of A in r2\n...\nstore r1 => r2 // content(A) = r1\nloadI 6 => r3\n// compute address of B in r4\n...\nstore r3 => r4 // content(B) = r3\nadd r1, r3 => r5\n// compute address of C in r6\n...\nstore r5 => r6 // content(C) = r1 + r3</code></pre></div>\n<p>Is this code correct?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo (var A, B)\n  A = 5;\n  B = 6;\n  C = A + B;\nend foo;\n\nX = 1\ncall foo(X,X);\nprint C;</code></pre></div>\n<p>Incorrect for call-by-reference!</p>\n<h3>Aliasing Problem</h3>\n<ul>\n<li>Aliasing: Two variables or source code names may refer to the same memory location</li>\n</ul>\n<p>Examples:</p>\n<ul>\n<li>Formal call-by-reference parameters a and b</li>\n<li>Pointers <code class=\"language-text\">a->f</code> and <code class=\"language-text\">b->f</code></li>\n<li>Array elements <code class=\"language-text\">a(i,j)</code> and <code class=\"language-text\">a(k,l)</code> if <code class=\"language-text\">i == k</code> and <code class=\"language-text\">j == l</code></li>\n</ul>\n<p>Channlenge: When is it safe to keep a variable’s value in a register across STORE instructions, i.e., while other STORE instructions are executed?</p>\n<h3>Memory Models</h3>\n<ul>\n<li>\n<p><strong>Register-register</strong> Model (<strong>We will use this one from now on</strong>)</p>\n<ul>\n<li>Values that <strong>may safely reside</strong> in registers are assigned to a unique virtual register (<strong>alias analysis</strong>)</li>\n<li>Register allocation/assignment maps virtual registers to limited set of physical registers</li>\n<li>Register allocation/assignment pass needed to make code “work”</li>\n</ul>\n</li>\n<li>\n<p><strong>Memory-Memory</strong> Model</p>\n<ul>\n<li>All values reside in memory, and are only kept in registers as briefly as possible (load operands from memory, perform computation, store result into memory)</li>\n<li>Register allocation/assignment has to try to identify cases where values can be safely kept in register</li>\n<li>Safety verification is hard at the low levels of program abstraction</li>\n<li>Even without register allocation/assignment, code will “work”</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"January 24, 2021","slug":"/compilers/lecture-2","title":"Compilers - Lecture 2"}}},"pageContext":{"id":"dd8e8e4e-72ea-5a9c-9906-20d1ad025dc8","frontmatter__slug":"/compilers/lecture-2","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}