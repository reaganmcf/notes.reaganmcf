{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-16/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 16 - Bottom-up Parsing</h1>\n<h2>LR(1) Skeleton Parser</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">stack.push(INVALID); stack.push(s0);\nnot_found = true;\ntoken = scanner.next_token();\ndo while (not_found) {\n  s = stack.top();\n  if (ACTION[s, token] == \"reduce A -> 𝝱\") {\n    stack.popnum(2 * |𝝱|);\n    s = stack.top();\n    stack.push(A);\n    stack.push(GOTO[s, A]);\n  } else if (ACTION[s, token] == \"shift si\") {\n    stack.push(token);\n    stack.push(si);\n    token &lt;- scanner.next_token();\n  } else if (ACTION[s, token] == \"accept\" &amp;&amp; token == EOF) {\n    not_found = false;\n  } else {\n    report a syntax error and recover;\n  }\n}\n\nreport success</code></pre></div>\n<p>The skeleton parser:</p>\n<ul>\n<li>Uses ACTION &#x26; GOTO tables</li>\n<li>Does |words| shifts</li>\n<li>Does |derivation| reductions</li>\n<li>Does 1 accept</li>\n</ul>\n<h2>Building LR(1) Parsers</h2>\n<p>How do we generate the ACTION and GOTO tables?</p>\n<ul>\n<li>Use the grammar to build a model of the DFA</li>\n<li>Use the model to build ACTION and GOTO tables</li>\n<li>If construction succeeds, the grammar is LR(1)</li>\n</ul>\n<p>The Big Picture:</p>\n<ul>\n<li>Model the state of the parser</li>\n<li>Use two functions <code class=\"language-text\">goto(s, X)</code> and <code class=\"language-text\">closure(s)</code>\n<ul>\n<li><code class=\"language-text\">goto()</code> is analagous to <code class=\"language-text\">move()</code> in subset construction</li>\n<li><code class=\"language-text\">closure()</code> adds information to round out a state</li>\n</ul>\n</li>\n<li>Build up states and transition functions of the DFA</li>\n<li>Use the information to fill in the ACTION and GOTO tables</li>\n</ul>\n<h2>LR(k) items</h2>\n<p>The LR(1) table construction algorithm uses LR(1) items to represent valid configurations of an LR(1) parser</p>\n<p>An LR(k) item is a pair [P, x] where</p>\n<ul>\n<li>P is a production A -> 𝝱 with a . at some position in the rhs</li>\n<li>x is a look ahead string of length &#x3C;= k</li>\n<li>The . in an item indicates the position in the top of the stack</li>\n</ul>\n<p>LR(1):</p>\n<ul>\n<li>[A -> .𝝱𝝲, a] means that the input seen so far is consistent with the use of A -> 𝝱𝝲 immediately after the symbol on the top of the stack</li>\n<li>[A -> 𝝱.𝝲, a] means that the input seen so far is consistent with the use of A -> 𝝱𝝲 at this point in the parse, <em>and</em> that the parser has already recognized 𝝱</li>\n<li>[A -> 𝝱𝝲., a] means that the parser has seen 𝝱𝝲, <em>and</em> that a look ahead symbol of a is consistent with reducing to A.</li>\n</ul>\n<h3>LR(1) items</h3>\n<p>The production A -> 𝝱, where 𝝱 = B1B2B3 with look ahead a, can give rise to 4 items</p>\n<p><img src=\"https://i.gyazo.com/5ffd093252df4fd6ec1467e30e728e9b.png\" alt=\"\"></p>\n<p>The set of LR(1) items for a grammar is <em>finite</em></p>\n<p>What’s the point of all these look ahead symbols?</p>\n<ul>\n<li>Carry them along to choose the correct reduction, <strong>if there is a choice</strong></li>\n<li>Look ahead’s are bookkeeping, unless item has a · at the right end\n<ul>\n<li>Has no direct use in [A -> 𝝱·𝝲]</li>\n<li>In [A -> 𝝱·, a], a look ahead of a implies a reduction by A -> 𝝱</li>\n<li>For { [A -> 𝝱·, a], [B -> 𝝲·c, b] }, a => reduce to A; c => shift</li>\n</ul>\n</li>\n<li>Limited right context is enough to pick the choices (unique, i.e., deterministic choice)</li>\n</ul>\n<h2>LR(1) Table Construction</h2>\n<p>High level overview</p>\n<ol>\n<li>Build the <strong>canonical collection of sets of LR(1) Items, <em>I</em></strong></li>\n</ol>\n<ul>\n<li>Begin in an appropriate state, s0\n<ul>\n<li>Assume S’ -> S, and S’ is unique start symbol that does not occur on any RHS of a production</li>\n<li>[S’ -> ·S, EOF] along with any equivalent items</li>\n<li>Derive equivalent items as <code class=\"language-text\">closure(s0)</code></li>\n</ul>\n</li>\n<li>Repeatedly compute, for each sk, and each X, <code class=\"language-text\">goto(sk, X)</code>\n<ul>\n<li>If the set is not already in the collection, add it</li>\n<li>Record all the transitions created by <code class=\"language-text\">goto()</code></li>\n<li>This eventually reaches a fixed point</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Fill in the table from the collection of sets of LR(1) items</li>\n</ol>\n<p><em>The canonical collection completely encodes the transition diagram for the handle-finding DFA</em></p>\n<h3>Computing Closures</h3>\n<p><code class=\"language-text\">closure(s)</code> adds all the items implied by items already in s</p>\n<ul>\n<li>Any item [A -> 𝝱·Bφ, a] implies [B -> ·𝛕, x] for each production with B on the <em>lhs</em>, and each x ∈FIRST(φa)</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/1c40368d08528f5a6ac5370cab994ce5.png\" alt=\"\"></p>\n<h3>Computing Gotos</h3>\n<p><code class=\"language-text\">goto(s,x)</code> computes the state that the parser would reach if it recognized an X while in state <em>s</em></p>\n<ul>\n<li>Goto({ [A -> 𝝱·Xφ, a]}, X) produces [A -> 𝝱X·φ, a] (easy part)</li>\n<li>Should also include closure([A -> 𝝱X·φ, a])</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/57aa9f2768db033ae82e6eaaf1e8c118.png\" alt=\"\"></p>\n<h3>Building the Canonical Collection</h3>\n<ul>\n<li>Start from s0 = closure([S’ -> S, EOF])</li>\n<li>Repeatedly construct new states, until all are found</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/2ca74253f86d9c4a9080e5ff2ae03699.png\" alt=\"\"></p>","frontmatter":{"date":"March 23, 2021","slug":"/compilers/lecture-16","title":"Compilers - Lecture 16"}}},"pageContext":{"id":"149cc40a-b612-5587-a0af-d0885b9f7476","frontmatter__slug":"/compilers/lecture-16","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}