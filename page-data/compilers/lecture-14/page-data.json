{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-14/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Lecture 14</h1>\n<h2>FIRST Set</h2>\n<p><img src=\"https://i.gyazo.com/0f51feb3054d499030c81889f2d510cf.png\" alt=\"\"></p>\n<p>To build FIRST(ğ›‚) for ğ›‚ = X1, X2, â€¦, Xn:</p>\n<ol>\n<li>\n<p>a âˆˆ FIRST(ğ›‚) if a âˆˆ FIRST(Xi) and ğ›† âˆˆ FIRST(Xj) for all 1 &#x3C;= j &#x3C;= i</p>\n</li>\n<li>\n<p>ğ›† âˆˆ FIRST(ğ›‚) if ğ›† âˆˆ FIRST(Xi) for all 1 &#x3C;= i &#x3C;= n</p>\n</li>\n</ol>\n<h2>FOLLOW Set</h2>\n<p>For a non-terminal A, define FOLLOW(A) as <strong>the set of terminals that can appear immediately to the right of A in some sentential form</strong></p>\n<p>Thus, a non-terminalâ€™s FOLLOW set specifies the tokens that can legally appear after it; a terminal has no FOLLOW set</p>\n<p><em>FOLLOW(A) = { a âˆˆ (T âˆª {eof})| S eof =>* ğ›‚ A a ğ›„ }</em></p>\n<p>To build FOLLOW(X) for all non-terminal X:</p>\n<ol>\n<li>Place eof in FOLLOW(<goal>)</li>\n</ol>\n<ul>\n<li>iterate until no more terminals or eof can be added to any FOLLOW(X):</li>\n</ul>\n<ol start=\"2\">\n<li>If A -> ğ›‚Bğ›ƒ then</li>\n</ol>\n<ul>\n<li>put {FIRST(ğ›ƒ) - ğ›†} in FOLLOW(B)</li>\n</ul>\n<ol start=\"3\">\n<li>If A -> ğ›‚B then</li>\n</ol>\n<ul>\n<li>put FOLLOW(A) in FOLLOW(B)</li>\n</ul>\n<ol start=\"4\">\n<li>If A -> ğ›‚Bğ›ƒ and ğ›† âˆˆ FIRST(ğ›ƒ) then</li>\n</ol>\n<ul>\n<li>put FOLLOW(A) in FOLLOW(B)</li>\n</ul>\n<h2>Predictive Parsing</h2>\n<p>If A -> ğ›‚ and A -> ğ›ƒ and ğ›† âˆˆ FIRST(ğ›‚), then we need to ensure that FIRST(ğ›ƒ) is disjoint from FOLLOW(A), too</p>\n<p><img src=\"https://i.gyazo.com/b8a2d77bf24960933c2b9eb7c82f922a.png\" alt=\"\"></p>\n<p>This means that we need to update our LL(1) property to be:</p>\n<p><strong>A grammar is LL(1) iff A -> ğ›‚ and A -> ğ›ƒ implies FIRST+(ğ›‚) âˆ© FIRST+(ğ›ƒ) = âˆ…</strong></p>\n<ul>\n<li>Notice we use FIRST+ instead of FIRST, in order to deal with ğ›†</li>\n</ul>\n<p>This would allow the parser to make a correct choice with a look ahead of exactly one symbol!</p>\n<h3>Building Top Down Parsers</h3>\n<p>Building the complete table</p>\n<ul>\n<li>Need a row for every NT &#x26; a column for every T + â€œeofâ€</li>\n<li>Need an algorithm to build the table</li>\n</ul>\n<p>Filling in TABLE[X,y], X âˆˆ NT, y âˆˆ T âˆª { eof }</p>\n<ul>\n<li>entry is the rule X -> ğ›ƒ, if y âˆˆ FIRST+(ğ›ƒ)</li>\n<li>entry is <em>error</em> otherwise</li>\n</ul>\n<p>If any entry is defined multiple times, G is not LL(1)</p>\n<h3>LL(1) Skeleton Parser</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">token = next_token() // scanner call\npsuh EOF onto Stack\npush the start symbol, S, onto Stack\nTOS = top of Stack\n\nloop forever\n  if TOS = EOF and token = EOF then\n    break and report success\n  else if TOS is a terminal token then\n    if TOS matches token then\n      pop Stack  // recognized TOS\n      token = next_token()\n    else report error looking for TOS\n  else  // TOS is a non-terminal symbol\n    if TABLE[TOS, token] is A -> B1,B2,...,Bk then\n      pop Stack // get rid of A\n      push Bk,Bk-1,...,B1 // in that order\n    else report error expanding TOS\n  TOS = top of Stack</code></pre></div>\n<h4>LL(1) Parser Example</h4>\n<p>Table-drive LL(1) parser</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a</th>\n<th>b</th>\n<th>eof</th>\n<th>other</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S</td>\n<td>aSb</td>\n<td>ğ›†</td>\n<td>ğ›†</td>\n<td>error</td>\n</tr>\n</tbody>\n</table>\n<p>How to parse input <code class=\"language-text\">aaabbb</code>?\nDescribe action as sequence of states <strong>(PDA stack content, remaining input, next action)</strong>, use eof as bottom-of-stack marker</p>\n<p>PDA stack content: [X, â€¦ Z], where Z is the TOS\nnext actions: <strong>rule</strong> or <strong>next input + pop</strong> or <strong>error</strong> or <strong>accept</strong></p>\n<p><img src=\"https://i.gyazo.com/6883bc2c83955739401d7752fd398463.png\" alt=\"\"></p>\n<h3>Recursive descent LL(1) parser</h3>\n<ol>\n<li>Every NT is associated with a parsing procedure</li>\n<li>The parsing procedure for A âˆˆ NT, proc A, is responsible to parse and consume any (token) string that can be derived from A; it may recursively call other parsing procedures</li>\n<li>The parser is invoked by calling <strong>proc S</strong> for start symbol <strong>S</strong></li>\n</ol>\n<h3>Reminder: Left Recursion</h3>\n<p><strong>Top-down parsers cannot handle left-recursive grammars</strong></p>\n<p>Our expression grammar is left recursive</p>\n<ul>\n<li>This can lead to non-termination in a top-down parser</li>\n<li>For a top-down parser, any recursion must be right recursion</li>\n<li>We would like to convert the left recursion to right recursion</li>\n</ul>\n<h3>Left Factoring</h3>\n<p>What if my grammar does not have the LL(1) property?\n=> Sometimes, we can transform the grammar</p>\n<p>The algorithm\n<img src=\"https://i.gyazo.com/ca9c56f7748482b763221d75adc5cc6b.png\" alt=\"\"></p>\n<p>A graphical example:\n<img src=\"https://i.gyazo.com/546af801ca6cf0f60b6f17cfa395d385.png\" alt=\"\"></p>\n<p>Consider the following fragment of the expression grammar</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Factor  -> Identifier\n         | Identifier [ExprList]\n         | Identifier (ExprList)</code></pre></div>\n<p>After left factoring, it becomes</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Factor    -> Identifier Arguments\nArguments -> [ExprList]\n          -> (ExprList)\n          -> ğ›†</code></pre></div>\n<p>This form has the same syntax, with the LL(1) property</p>\n<p><img src=\"https://i.gyazo.com/eaeb747bc3bee6a43a4a6cd807dd8d8c.png\" alt=\"\"></p>\n<h3>LL(1) Grammars</h3>\n<p>Question: By eliminating left recursion and left factoring, can we transform an arbitrary CFG to a form where it meets the LL(1) condition? (and can be parsed predictively with single token look ahead?)</p>\n<p>Answer: Given a CFG that doesnâ€™t meet the LL(1) condition, it is undecidable whether or not an equivalent LL(1) grammar exists.</p>","frontmatter":{"date":"March 09, 2021","slug":"/compilers/lecture-14","title":"Compilers - Lecture 14"}}},"pageContext":{"id":"73453e55-af43-5254-bb71-82a75c5f276c","frontmatter__slug":"/compilers/lecture-14","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}