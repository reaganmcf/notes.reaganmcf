{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/compilers/lecture-12/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Parsing (Syntax Analysis)</h1>\n<p><img src=\"https://i.gyazo.com/3b9ee4b7a8e089c58c00c3d28ba7e887.png\" alt=\"\"></p>\n<p>Parser</p>\n<ul>\n<li>Checks the stream of <em>words</em> and their <em>parts of speech</em> (produced by the scanner) for grammatical correctness</li>\n<li>Determines if input is syntactically well-formed</li>\n<li>Guides checking at deeper levels than syntax</li>\n<li>Builds an IR representation of the code</li>\n</ul>\n<h2>The Study of Parsing</h2>\n<p>The process of discovering a <em>derivation</em> for some sentence</p>\n<ul>\n<li>Need a mathematical model of syntax - a grammar <em>G</em></li>\n<li>Need an algorithm for testing membership in <em>L(G)</em></li>\n<li>Need to keep in mind that our goal is building parsers, not studying the mathematics of arbitrary languages</li>\n</ul>\n<p>Roadmap</p>\n<ol>\n<li>Context-free grammars and derivations</li>\n<li>Top-down parsing</li>\n</ol>\n<ul>\n<li>LL(1) parsers, hand-coded recursive descent parsers</li>\n</ul>\n<ol start=\"3\">\n<li>Bottom-up parsing</li>\n</ol>\n<ul>\n<li>Automatically generated LR(1) parsers</li>\n</ul>\n<h3>Specifying Syntax with a Grammar</h3>\n<p>Context-free syntax is specified with a context-free grammar</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SheepNoise -> SheepNoise baa\n                | baa</code></pre></div>\n<p>This <em>CFG</em> defines the set of noises sheep normally make</p>\n<p>It is written in a variant of Backus-Naur form</p>\n<p>Formally, a grammar is a four tuple, <em>G = (S, N, T, P)</em>, where</p>\n<ul>\n<li><em>S</em> is the <em>start symbol</em> (set of strings in L(G))</li>\n<li><em>N</em> is the set of <em>non-terminal symbols</em> (syntactic variables)</li>\n<li><em>T</em> is a set of <em>terminal symbols</em> (words or tokens)</li>\n<li><em>P</em> is a set of <em>productions</em> or <em>rewrite rules</em> (<em>P: N -> N ∪ T)*</em>)</li>\n</ul>\n<p><strong>L(G) = { w ∈ T* | S =>* w }</strong></p>\n<h2>A Simple Expression Grammar</h2>\n<p>To explore the uses of CFGs, we need a more complex grammar G</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Expr -> Expr Op Expr\n      | number\n      | id\nOp   -> +\n      | -\n      | \\*\n      | /</code></pre></div>\n<ul>\n<li>Such a sequence of rewrites is called a <em>derivation</em></li>\n<li>Process of discovering a derivation is called <em>parsing</em></li>\n</ul>\n<p>Is <code class=\"language-text\">x - 2 \\* y</code> ∈ L(G)?</p>\n<table>\n<thead>\n<tr>\n<th>Rule</th>\n<th>Sentential Form</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>Expr</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Expr Op Expr</td>\n</tr>\n<tr>\n<td>3</td>\n<td>&#x3C;id,x> Op Expr</td>\n</tr>\n<tr>\n<td>5</td>\n<td>&#x3C;id,x> - Expr</td>\n</tr>\n<tr>\n<td>1</td>\n<td>&#x3C;id,x> - Expr Op Expr</td>\n</tr>\n<tr>\n<td>2</td>\n<td>&#x3C;id,x> - &#x3C;num,2> Op Expr</td>\n</tr>\n<tr>\n<td>6</td>\n<td>&#x3C;id,x> - &#x3C;num,2> * Expr</td>\n</tr>\n<tr>\n<td>3</td>\n<td>&#x3C;id,x> - &#x3C;num,2> * &#x3C;id,y></td>\n</tr>\n</tbody>\n</table>\n<h3>Derivations</h3>\n<ul>\n<li>At each step, we choose a non-terminal to replace</li>\n<li>Different choices can lead to different derivations</li>\n</ul>\n<p>Two derivations are of interest</p>\n<ul>\n<li><strong>Leftmost derivation</strong> - replace the leftmost NT at each step\n<ul>\n<li>Generates <em>left sequential forms</em> (=>*lm)</li>\n</ul>\n</li>\n<li><strong>Rightmost derivation</strong> - replace the rightmost NT at each step\n<ul>\n<li>Generates <em>right sequential forms</em> (=>*rm)</li>\n</ul>\n</li>\n</ul>\n<p>These are the two <em>systematic derivations</em></p>\n<ul>\n<li>We don’t care about randomly-ordered derivations!</li>\n</ul>\n<p>The example above was a <em>leftmost</em> derivation</p>\n<ul>\n<li>Of course, there is also a <em>rightmost</em> derivation</li>\n<li>Interestingly, the resulting parse trees may be different</li>\n</ul>\n<h3>Parse Trees</h3>\n<p>Rule in our grammar: <code class=\"language-text\">Expr -> Expr Op Expr</code></p>\n<p>A single derivation step <code class=\"language-text\">... Expr ... => ... Expr Op Expr ...</code> can be represented as a tree structure with the left-hand side non-terminal as the root, and all right-hand side symbols as the children (ordered left to right)</p>\n<p>The entire derivation of a sentence in the language can be represented as a <strong>parse tree</strong> with the start symbol as its root, and leave nodes that are all terminal symbols</p>\n<p>NOTE: <strong>the structure of the parse tree has semantic significance</strong></p>\n<h3>Two derivations for <code class=\"language-text\">x - 2 * y</code></h3>\n<p><img src=\"https://i.gyazo.com/3dbe3ab56f9b280d26edaf889003860f.png\" alt=\"\"></p>\n<p>In both cases, <code class=\"language-text\">Expr =>* id - num * id</code></p>\n<ul>\n<li>The two derivations produce different parse trees</li>\n<li>The parse trees imply different evaluation orders!</li>\n</ul>\n<h3>Derivations and Precedence</h3>\n<p>These two derivations point out a problem with the grammar. How to resolve ambiguity?\nAnswer: <strong>Change grammar to enforce operator <em>precendence and associativity</em></strong></p>\n<p>To add precedence</p>\n<ul>\n<li>Create a non-terminal for each <em>level of precendence</em></li>\n<li>Isolate the corresponding part of the grammar</li>\n<li>Force the parser to recognize high precendence subexpressions first</li>\n</ul>\n<p>For algebraic expressions</p>\n<ul>\n<li>Multiplication and division, first (level one)</li>\n<li>Subtraction and addition, next (level two)</li>\n</ul>\n<blockquote>\n<p>Note: we are ignoring the issue of associativity for now</p>\n</blockquote>\n<p>Adding the standard algebraic precendence produces:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Goal    -> Expr\nExpr    -> Expr + Term\n         | Expr - Term\n         | Term\nTerm    -> Term * Factor\n         | Term / Factor\n         | Factor\nFactor  -> number\n         | id</code></pre></div>\n<p>The grammar is slightly larger</p>\n<ul>\n<li>Takes more rewriting to reach some terminal symbols</li>\n<li>Encodes expected precedence</li>\n<li>Produces same parse tree under leftmost &#x26; rightmost derivations</li>\n</ul>\n<p>Let’s see how it parses x - 2 * y</p>\n<p><img src=\"https://i.gyazo.com/71e06409572bfaec31bbc9ede7aba0b3.png\" alt=\"\"></p>\n<p>This produces <code class=\"language-text\">x - (2 * y)</code>, along with an appropriate parse tree.\nBoth the leftmost and rightmost derivations give the same expression, because the grammar directly encodes the desired precedence.</p>\n<h2>Ambiguous Grammars</h2>\n<p>Definitions</p>\n<ul>\n<li>If a grammar has more than one leftmost derivation for a single <em>sentential form</em>, the grammar is <strong>ambiguous</strong></li>\n<li>If a grammar has more than one rightmost derivation for a single <em>sentential form</em>, the grammar is <strong>ambiguous</strong></li>\n<li>The leftmost and rightmost derivations for a sentential form may differ, even in an unambiguous grammar</li>\n</ul>\n<p>Classic example - the <code class=\"language-text\">if-then-else</code> problem</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Stmt -> if Expr then Stmt\n      | if Expr then Stmt else Stmt\n      | ... other stmts ...</code></pre></div>\n<p>This ambiguity is entirely grammatical in nature</p>\n<p>This sequential form has two derivations\n<code class=\"language-text\">if Expr then if Expr then Stmt else Stmt</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if Expr then\n  if Expr then Stmt\n  else Stmt</code></pre></div>\n<p>OR</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if Expr then\n  if Stmt then Stmt\nelse Stmt</code></pre></div>\n<h3>Removing the Ambiguity</h3>\n<ul>\n<li>We must rewrite the grammar to avoid generating the problem</li>\n<li>Match each <em>else</em> to innermost unmatched if (common sense rule)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Stmt     -> WithElse\n          | NoElse\nWithElse -> if Expr then WithElse else WithElse\n          | OtherStmt\nNoElse   -> if Expr then Stmt\n          | if Expr then WithElse else NoElse</code></pre></div>\n<h3>Deeper Ambiguity</h3>\n<p>Ambiguity usually refers to confusion in the CFG</p>\n<p>Overloading can create a deeper ambiguity</p>\n<ul>\n<li><code class=\"language-text\">a = f(17)</code></li>\n<li>In many Algol-like languages, f could either be a function or a subscripted variable</li>\n</ul>\n<p>Disambiguing this one requires context</p>\n<ul>\n<li>Really an issue of <em>type</em>, not context-free syntax</li>\n<li>Requires extra-grammatical solution (not in CFG)</li>\n<li>Must handle these with a different mechanism\n<ul>\n<li>Step outside grammar rather than use a more complex grammar</li>\n</ul>\n</li>\n</ul>\n<h3>Final Word</h3>\n<p>Ambiguity arises from two distinct sources</p>\n<ul>\n<li>Confusion in the context-free syntax</li>\n<li>Confusion that requires context to resolve</li>\n</ul>\n<p>Resolving ambiguity</p>\n<ul>\n<li>To remove context-free ambiguity, rewrite the grammar</li>\n<li>Change language (e.g.: if … endif)</li>\n<li>To handle context-sensitive ambiguity takes cooperation\n<ul>\n<li>Knowledge of declarations, types, …</li>\n<li>Accept a superset of L(G) &#x26; check it by other means</li>\n<li>This is a language design problem</li>\n</ul>\n</li>\n</ul>\n<p>Sometimes, the compiler writer accepts an ambiguous grammar</p>\n<ul>\n<li>Parsing techniques that “do the right thing”</li>\n<li>i.e., always select the same derivation</li>\n</ul>\n<h2>Parsing Techniques</h2>\n<h3>Top-down Parsers</h3>\n<p>LL(1), recursive descent</p>\n<ul>\n<li>Input: read left-to-right</li>\n<li>Construction leftmost derivation (forwards)</li>\n<li>1 input symbol look ahead</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/bba8b2cf034e19ca5d7b09349965be93.png\" alt=\"\"></p>\n<h3>Bottom-up parsers</h3>\n<p>LR(1), operator precedence</p>\n<ul>\n<li>Input: read left-to-right</li>\n<li>Construct rightmost derivation (backwards)</li>\n<li>1 input symbol look ahead</li>\n</ul>\n<p><img src=\"https://i.gyazo.com/54f74ee2e5b4256fccb4c666a0eab788.png\" alt=\"\"></p>\n<h3>Comparing them both</h3>\n<p><img src=\"https://i.gyazo.com/814123516ae7b5ea1a5e8e5c30695863.png\" alt=\"\"></p>\n<p><img src=\"https://i.gyazo.com/0093a23fc090fb7e6626c6e01043c233.png\" alt=\"\"></p>","frontmatter":{"date":"March 02, 2021","slug":"/compilers/lecture-12","title":"Compilers - Lecture 12"}}},"pageContext":{"id":"8839c154-c07b-54a1-83e0-37558f52a309","frontmatter__slug":"/compilers/lecture-12","__params":{"frontmatter__slug":"compilers"}}},
    "staticQueryHashes": ["1727495174"]}